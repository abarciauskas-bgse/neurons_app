<!DOCTYPE html>
<html>
    <meta charset="utf-8">
    <head>
        <style>
            body {
                /*background: #333;*/
            }
            #container {
                width: 1024px;
                display: block;
                margin: 50px auto;
            }
        </style>
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    </head>


    <body>
        <div id="container"></div>
    </body>

    <footer>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src="javascripts/colorbrewer.min.js"></script>
        <script src="javascripts/underscore.js"></script>
        <script>
            // LAYOUT
            var num_classes = 11,
                num_neurons = 2,
                num_layers = 2,
                width = 1024,
                height = 768, // height of whole container
                header_height = 100,
                unit_width = 20,
                unit_height = unit_width,
                transfer_width = 60,
                song_bars_height = 100,
                songs_bar_y_offset = height - song_bars_height,
                song_bars_group_length = width,
                inner_margin = 20,
                neuron_y_offset = 30,
                layer_width = width/2,
                neuron_width = (layer_width - 3*unit_width - 2*transfer_width - inner_margin),
                neuron_height = (height // height dynamically defined by other factors
                    - header_height
                    - 2*neuron_y_offset // offset from top and bottom of the network
                    - inner_margin*(num_neurons-1) // space between neurons in a layer
                    - song_bars_height)/num_neurons, // divide by number of neurons
                network_y_position = neuron_y_offset + header_height,
                weights_group_height = num_classes*unit_height,
                unit_group_y_position = network_y_position + (2*neuron_height + inner_margin)/2 - weights_group_height/2,
                light_grey = '#ededed',
                medium_grey = '#ccc'


            var kolors = d3.scale.ordinal()
                .domain(d3.range(0,num_classes))
                .range(colorbrewer.Spectral[num_classes]);

            var svg = d3.select("#container").append("svg")
                .attr("width", width+2)
                .attr("height", height)

            //svg.append('line').attr('x1', 1024/2).attr('x2', 1024/2).attr('y1', 0).attr('y2', 768).attr('stroke', 'black')

            var unit_sets = []
            var UnitSet = function(type, layer) {
                this.class = 'UnitSet';
                this.type = type;
                this.layer = layer;
                this.y_offset = unit_group_y_position;
                this.y_position = unit_group_y_position;
                unit_sets.push(this)
            }

            second_layer_visible = true;
            UnitSet.prototype.x_position = function() {
                var position = null;
                switch(this.type) {
                    case 'input':
                        // Not really sure about the second case, could be we use the output from layer 0
                        position = (this.layer == 0) ? 0 : layer_width;
                        break;
                    case 'output':
                        var layer_offset = unit_width + 2*transfer_width + neuron_width
                        position = (this.layer == 0) ? layer_offset : (layer_width + layer_offset)
                        break;
                    case 'target':
                        position = (this.layer == 0) ? (layer_width - unit_width) : (width - unit_width)
                        break;
                }
                return position;
            };

            UnitSet.prototype.add = function() {
                group = svg.append("g")
                    .attr("class", "units_group")
                    .attr("id", "unit_group_" + this.type + "L" + this.layer)
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_offset + ")")
                group.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', "unit_" + this.type + "L" + this.layer)
                        .attr('stroke', light_grey)
                        .attr('fill', 'white')
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})                                    
            };

            var neurons = []
            Neuron = function(layer, index) {
                this.layer = layer;
                this.index = index;
                this.height = neuron_height;
                this.width = neuron_width
                neurons.push(this)
            }

            Neuron.prototype.y_position = function() {
                return (this.index == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin)
            }

            var neuron_x_offset = unit_width + transfer_width
            Neuron.prototype.x_position = function() {
                return (this.layer == 0) ? neuron_x_offset : (layer_width + neuron_x_offset)
            }

            Neuron.prototype.add = function() {
                group = svg.append("g")
                    .attr("class", "neuron_group")
                    .attr("id", "neuron_group_L" + this.layer  + "_N" + this.index)
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_position() + ")") 
                group.append('rect')
                    .attr('class', 'neuron_container')
                    .attr('width', neuron_width)
                    .attr('height', neuron_height)
                    .attr('fill', light_grey)
            }

            var weight_sets = []
            WeightSet = function(type, layer, neuron) {
                this.class = 'WeightSet';
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - weights_group_height)/2; // equally spaced from top and bottom of neuron container
                // FIXME: Hacky - duplicates code from Neuron#y_position
                this.y_position = this.y_offset + ((neuron == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin))
                weight_sets.push(this)
            }

            WeightSet.prototype.x_offset = function() {
                return (this.type == 'xw') ? inner_margin : (neuron_width - inner_margin - unit_width)
            }

            WeightSet.prototype.add = function() {
                // DRY id attribution
                var neuron_group = d3.select("#neuron_group_L" + this.layer + "_N" + this.neuron)
                var weights_group = neuron_group.append('g')
                                        .attr('class','weights_group')
                                        .attr('id', 'weights_group_L' + this.layer + '_N' + this.neuron + '_' + this.type)
                                        .attr('transform', 'translate(' + this.x_offset() + ',' + this.y_offset + ')')

                // DRY me with UnitSet#add
                weights_group.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', "weight_" + this.type + "_L" + this.layer + "_N" + this.neuron)
                        .attr('stroke', light_grey)
                        .attr('fill', 'white')
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})
            }

            var hidden_states = []
            var HiddenState = function(layer, neuron) {
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - unit_height)/2;
                this.x_offset = (neuron_width - unit_width)/2;
                hidden_states.push(this)
            }

            HiddenState.prototype.add = function() {
                var neuron_group = d3.select("#neuron_group_L" + this.layer + "_N" + this.neuron)
                neuron_group.append('rect')
                    .attr('class', 'hidden_state_unit')
                    .attr('id', 'hidden_state_unit_L' + this.layer + '_N' + this.neuron)
                    .attr('stroke', light_grey)
                    .attr('fill', 'white')
                    .attr('width', unit_width)
                    .attr('height', unit_height)
            }

            var tl_sets = [];
            var TransferLineSet = function(type, layer, neuron) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.d3_group = null;
                this.source = null;
                this.target = null;
                switch(type) {
                    case 'xw':                    
                        this.source = _.findWhere(unit_sets, {type: 'input', layer: layer})
                        console.log(layer)
                        this.target = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        break;
                    case 'hy':
                        this.source = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        this.target = _.findWhere(unit_sets, {type: 'output', layer: layer})
                        break;
                }
                console.log(this.source)
                tl_sets.push(this)
            }

            TransferLineSet.prototype.x_offset = function() {
                var x_offset = null;
                switch(this.type) {
                    case 'xw':
                        x_offset = (this.layer == 0) ? unit_width : (layer_width + unit_width);
                        break;
                    case 'wxh':
                        x_offset = 2*unit_width + transfer_width;
                        break;
                    case 'hh':
                        x_offset = unit_width + transfer_width + neuron_width/2 + unit_width/2;
                        break;
                    case 'hy':
                        x_offset = (this.layer == 0) ? (transfer_width + neuron_width) : (layer_width + transfer_width + neuron_width);
                        break;
                }
                return x_offset;
            }

            TransferLineSet.prototype.add = function() {
                // add a group with x offset
                group = svg.append('g')
                           .attr('class', 'tl_set_group')
                           .attr('id', 'tl_set_group_L' + this.layer + '_N' + this.neuron + '_T' + this.type)
                           .attr('transform', 'translate(' + this.x_offset() + ',0)')
                this.d3_group = group;
                // add a transfer line for every class in num_classes
                if (this.type == 'xw' || this.type == 'hy') {
                    for (i = 0; i < num_classes; i++) {
                        tline = new TransferLine(this.type, this.layer, this.neuron, this, i)
                        tline.add()
                    }
                }
            }

            var tlines = [];
            var TransferLine = function(type, layer, neuron, set, index) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.set = set;
                this.index = index;
                this.source = set.source;
                this.target = set.target;
                tlines.push(this)
            }

            var transfer_line_function = d3.svg.line().interpolate("basis");

            TransferLine.prototype.add = function() {
                source_y = this.source.y_position
                target_y = this.target.y_position
                unit_offset = unit_height*this.index + unit_height/2
                full_transfer_width = transfer_width + inner_margin;
                line_data = [
                    [0, source_y + unit_offset],
                    [full_transfer_width/4, source_y + unit_offset],
                    [3*full_transfer_width/4, target_y + unit_offset],
                    [full_transfer_width, target_y + unit_offset]
                ]
                this.set.d3_group.append("path")
                    .attr("d", transfer_line_function(line_data))
                    .attr('class', 'link')
                    .attr("stroke", medium_grey)
                    .attr("stroke-width", 2)//unit_height/2)
                    .attr('fill', 'none');  
            }

            add_network = function() {
                // add input units
                unitsets = [['input',0],['input',1],['output',0],['output',1],['target',0],['target',1]]
                for (i = 0; i < unitsets.length; i++) {
                   unitset = new UnitSet(unitsets[i][0], unitsets[i][1])
                   unitset.add()
                }

                for (layer_i = 0; layer_i < num_layers; layer_i++) {
                    for (neuron_i = 0; neuron_i < num_neurons; neuron_i++) {
                        neuron = new Neuron(layer_i, neuron_i);
                        neuron.add()

                        weight_types = ['xw', 'hy']
                        weight_types.forEach(function(type) {
                            weight_set = new WeightSet(type, layer_i, neuron_i);
                            weight_set.add()
                        })

                        transfer_line_types = ['xw', 'hy']
                        transfer_line_types.forEach(function(type) {
                            tl_set = new TransferLineSet(type, layer_i, neuron_i)
                            tl_set.add()
                        });

                    }                    
                }
            };

            add_network()

            song_bars_group = svg.append("g")
                .attr("id", "#song_bars_group")
                .attr("transform", "translate(0," + songs_bar_y_offset + ")")
            song_bar_yscale = d3.scale.linear().domain([0,num_classes]).range([0, song_bars_height])

            d3.range(0,num_classes).forEach(function(d) {
                song_bars_group.append("line")
                    .attr("x1", 0)
                    .attr("y1", song_bar_yscale(d))
                    .attr("x2", width)
                    .attr("y2", song_bar_yscale(d))
                    .attr("stroke", light_grey)
            })

            // function plot_song(song)
            song_bar_note_height = song_bars_height/num_classes
            d3.json("daft_punk-one_more_time.json", function(data) {
                seq_length = d3.max(data.map(function(d) { return d.seq_idx }))
                song_bar_note_width = song_bars_group_length/seq_length + 1
                xscale = d3.scale.linear().domain([0,seq_length]).range([0, song_bars_group_length])
                song_bars_group.selectAll('rect')
                    .data(data).enter()
                      .append('rect').attr('class', 'song_bar_unit')
                      .attr('x', function(d) { return xscale(d.seq_idx) })
                      .attr('y', function(d) { return song_bar_yscale(d.note) })
                      .attr('height', song_bar_note_height)
                      .attr('width', song_bar_note_width)
                      .attr('fill', function(d) { return kolors(d.note) })
            })

        </script>
    </footer>
</html>
