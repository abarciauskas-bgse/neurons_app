<!DOCTYPE html>
<html>
    <meta charset="utf-8">
    <head>
        <style>
            body {
                /*background: #333;*/
            }
            #container {
                width: 1024px;
                display: block;
                margin: 50px auto;
            }

            .memory_cell {
                stroke: #ccc;
                stroke-width: 2px;
            }
        </style>
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    </head>


    <body>
        <div id="container"></div>
    </body>

    <footer>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src="javascripts/colorbrewer.min.js"></script>
        <script src="javascripts/underscore.js"></script>
        <script>
            // LAYOUT
            var num_classes = 11,
                num_neurons = 2,
                num_layers = 2,
                width = 1024,
                height = 768, // height of whole container
                header_height = 100,
                unit_width = 20,
                unit_height = unit_width,
                transfer_width = 60,
                song_plot_height = 100,
                songs_bar_y_offset = height - song_plot_height,
                song_plot_group_length = width,
                inner_margin = 20,
                neuron_y_offset = 30,
                layer_width = width/2,
                neuron_width = (layer_width - 3*unit_width - 2*transfer_width - inner_margin),
                neuron_height = (height // height dynamically defined by other factors
                    - header_height
                    - 2*neuron_y_offset // offset from top and bottom of the network
                    - inner_margin*(num_neurons-1) // space between neurons in a layer
                    - song_plot_height)/num_neurons, // divide by number of neurons
                network_y_position = neuron_y_offset + header_height,
                weight_set_height = num_classes*unit_height,
                unit_group_y_position = network_y_position + (2*neuron_height + inner_margin)/2 - weight_set_height/2,
                light_grey = '#ededed',
                medium_grey = '#ccc'


            var kolors = d3.scale.ordinal()
                .domain(d3.range(0,num_classes))
                .range(colorbrewer.Spectral[num_classes]);

            var svg = d3.select("#container").append("svg")
                .attr("width", width+2)
                .attr("height", height)

            //svg.append('line').attr('x1', 1024/2).attr('x2', 1024/2).attr('y1', 0).attr('y2', 768).attr('stroke', 'black')

            var unit_sets = []
            var UnitSet = function(type, layer) {
                this.class = 'UnitSet';
                this.type = type;
                this.layer = layer;
                this.y_offset = unit_group_y_position;
                this.y_position = unit_group_y_position;
                unit_sets.push(this)
            }

            second_layer_visible = true;
            UnitSet.prototype.x_position = function() {
                var position = null;
                switch(this.type) {
                    case 'input':
                        // Not really sure about the second case, could be we use the output from layer 0
                        position = (this.layer == 0) ? 0 : layer_width;
                        break;
                    case 'output':
                        var layer_offset = unit_width + 2*transfer_width + neuron_width
                        position = (this.layer == 0) ? layer_offset : (layer_width + layer_offset)
                        break;
                    case 'target':
                        position = (this.layer == 0) ? (layer_width - unit_width) : (width - unit_width)
                        break;
                }
                return position;
            };

            var css_identifier = function(object_type, object_type_type, layer, neuron, index) {
                return object_type
                    + (object_type_type == null ? '' : '_' + object_type_type)
                    + (layer == null ? '' : '_L' + layer)
                    + (neuron == null ? '' : '_N' + neuron)
                    + (index == null ? '' : '_i' + index)
            }
            UnitSet.prototype.add = function() {
                group = svg.append("g")
                    .attr("class", "units_group")
                    .attr("id", css_identifier('unit_set', this.type, this.layer, null, null))
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_offset + ")")
                var layer = this.layer
                var type = this.type
                group.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        // FIXME: may want a function for classes as well?
                        .attr('class', function(d, i) { return css_identifier('unit', type, layer, null, null) })
                        .attr('id', function(d, i) { return css_identifier('unit', type, layer, null, i) })
                        .attr('stroke', light_grey)
                        .attr('fill', 'white')
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})                                    
            };

            var neurons = []
            Neuron = function(layer, index) {
                this.layer = layer;
                this.index = index;
                this.height = neuron_height;
                this.width = neuron_width
                neurons.push(this)
            }

            Neuron.prototype.y_position = function() {
                return (this.index == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin)
            }

            var neuron_x_offset = unit_width + transfer_width
            Neuron.prototype.x_position = function() {
                return (this.layer == 0) ? neuron_x_offset : (layer_width + neuron_x_offset)
            }

            Neuron.prototype.add = function() {
                group = svg.append("g")
                    .attr("class", "neuron")
                    .attr("id", css_identifier("neuron", null, this.layer, this.index, null))
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_position() + ")") 
                group.append('rect')
                    .attr('class', 'neuron_container')
                    .attr('width', neuron_width)
                    .attr('height', neuron_height)
                    .attr('fill', light_grey)
            }

            var weight_sets = []
            WeightSet = function(type, layer, neuron) {
                this.class = 'WeightSet';
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - weight_set_height)/2; // equally spaced from top and bottom of neuron container
                // FIXME: Hacky - duplicates code from Neuron#y_position
                this.y_position = this.y_offset + ((neuron == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin))
                weight_sets.push(this)
            }

            WeightSet.prototype.x_offset = function() {
                return (this.type == 'xw') ? inner_margin : (neuron_width - inner_margin - unit_width)
            }

            WeightSet.prototype.add = function() {
                // DRY id attribution
                var neuron = d3.select("#neuron_L" + this.layer + "_N" + this.neuron)
                var weight_set = neuron.append('g')
                                        .attr('class','weight_set')
                                        .attr('id', css_identifier('weight_set', this.type, this.layer, this.neuron, 0))
                                        .attr('transform', 'translate(' + this.x_offset() + ',' + this.y_offset + ')')
                var layer = this.layer
                var type = this.type
                var neuron = this.neuron
                // DRY me with UnitSet#add
                weight_set.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', function(d, i) { return css_identifier('weight', type, layer, neuron, null) })
                        .attr('id', function(d, i) { return css_identifier('weight', type, layer, neuron, i) })
                        .attr('stroke', light_grey)
                        .attr('fill', 'white')
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})
            }

            var hidden_states = []
            var HiddenState = function(layer, neuron) {
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - unit_height)/2;
                this.y_position = this.y_offset + network_y_position + (neuron == 1 ? (neuron_height + inner_margin) : 0);
                this.x_offset = (neuron_width - unit_width)/2;
                hidden_states.push(this)
            }

            HiddenState.prototype.add = function() {
                var neuron = d3.select("#neuron_L" + this.layer + "_N" + this.neuron)
                
                neuron.append('rect')
                    .attr('class', 'hidden_state')
                    .attr('id', css_identifier('hidden_state', null, this.layer, this.neuron, null))
                    .attr('stroke', light_grey)
                    .attr('fill', 'white')
                    .attr('width', unit_width)
                    .attr('height', unit_height)
                    .attr('x', this.x_offset)
                    .attr('y', this.y_offset)

                memory_cell = new MemoryCell(this, neuron);                                                        
                memory_cell.add()
            }

            memory_cells =[]
            var MemoryCell = function(hidden_state, neuron) {
                this.hidden_state = hidden_state
                this.neuron = neuron
                memory_cells.push(this)
            }

            MemoryCell.prototype.add = function() {
               // Memory cell top
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_top')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset - unit_width)
                    .attr('y2', this.hidden_state.y_offset - unit_width)

                // memory cell right top
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_right_top')
                    .attr('x1', this.hidden_state.x_offset + 2*unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset - unit_width)
                    .attr('y2', this.hidden_state.y_offset + unit_width/2)

                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_right_bottom')
                    .attr('x1', this.hidden_state.x_offset + 2*unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset + unit_width/2)
                    .attr('y2', this.hidden_state.y_offset + 2*unit_width)

                // memory cell bottom
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_bottom')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset + 2*unit_width)
                    .attr('y2', this.hidden_state.y_offset + 2*unit_width)

                // memory cell left top
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_left_top')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset - unit_width)
                    .attr('y1', this.hidden_state.y_offset - unit_width)
                    .attr('y2', this.hidden_state.y_offset + unit_width/2)
                // memory cell left bottom
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_left_bottom')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset - unit_width)
                    .attr('y1', this.hidden_state.y_offset + unit_width/2)
                    .attr('y2', this.hidden_state.y_offset + 2*unit_width)
            }

            MemoryCell.prototype.open = function(duration, side) {
                new_x = this.hidden_state.x_offset
                if (side == 'left') {
                    new_x += -unit_width - 3*unit_width/2
                } else {
                    new_x += 3*unit_width
                }
                //new_x = this.hidden_state.x_offset + 3*unit_width
                // fix me: this transition should not change length of line in the interim
                this.neuron.selectAll('.memory_cell_' + side + '_top').transition()
                    .ease('cubic')
                    .duration(duration/2)
                    .attr('x2', new_x)
                    .attr('y2', this.hidden_state.y_offset - unit_width)

                this.neuron.selectAll('.memory_cell_' + side + '_bottom').transition()
                    .duration(duration/2)
                    .ease('cubic')
                    .attr('x1', new_x)
                    .attr('y1', this.hidden_state.y_offset + 3*unit_width/2 + unit_width/2)
            }

            MemoryCell.prototype.close = function(duration, side) {
                new_x = this.hidden_state.x_offset
                if (side == 'left') {
                    new_x += -unit_width
                } else {
                    new_x += 2*unit_width
                }                
                // fix me: this transition should not change length of line in the interim
                this.neuron.selectAll('.memory_cell_' + side + '_top').transition()
                    .duration(duration/2).delay(duration/2)
                    .attr('x2', new_x)
                    .attr('y2', this.hidden_state.y_offset + unit_width/2)

                this.neuron.selectAll('.memory_cell_' + side + '_bottom').transition()
                    .duration(duration/2).delay(duration/2)
                    .attr('x1', new_x)
                    .attr('y1', this.hidden_state.y_offset + unit_width/2)
            }

            var memory_cells_open_close = function(duration, side) {
                memory_cells.forEach(function(mc) {
                    mc.open(duration, side)
                })
                memory_cells.forEach(function(mc) {
                    mc.close(duration, side)
                })                
            }

            var tl_sets = [];
            var TransferLineSet = function(type, layer, neuron) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.d3_group = null;
                this.source = null;
                this.target = null;
                switch(type) {
                    case 'xw':                    
                        this.source = _.findWhere(unit_sets, {type: 'input', layer: layer})
                        this.target = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        break;
                    case 'wxh':
                        this.source = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        this.target = _.findWhere(hidden_states, {layer: layer, neuron: neuron})
                        break;
                    case 'hh':
                        this.source = _.findWhere(hidden_states, {layer: layer, neuron: neuron})
                        this.target = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        break;
                    case 'hy':
                        this.source = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        this.target = _.findWhere(unit_sets, {type: 'output', layer: layer})
                        break;
                }
                tl_sets.push(this)
            }

            TransferLineSet.prototype.x_offset = function() {
                var x_offset = null;
                switch(this.type) {
                    case 'xw':
                        x_offset = (this.layer == 0) ? unit_width : (layer_width + unit_width);
                        break;
                    case 'wxh':
                        layer_wxh_offset = 2*unit_width + transfer_width + inner_margin;
                        x_offset = (this.layer == 0) ? layer_wxh_offset : layer_width + layer_wxh_offset;
                        break;
                    case 'hh':
                        layer_hh_offset = unit_width + transfer_width + neuron_width/2 + unit_width/2;
                        x_offset = (this.layer == 0) ? layer_hh_offset : layer_width + layer_hh_offset;
                        break;
                    case 'hy':
                        x_offset = (this.layer == 0) ? (transfer_width + neuron_width) : (layer_width + transfer_width + neuron_width);
                        break;
                }
                return x_offset;
            }

            TransferLineSet.prototype.add = function() {
                // add a group with x offset
                group = svg.append('g')
                           .attr('class', 'tl_set')
                           .attr('id', css_identifier('tl_set', this.type, this.layer, this.neuron, null))
                           .attr('transform', 'translate(' + this.x_offset() + ',0)')
                this.d3_group = group;
                // add a transfer line for every class in num_classes
                if (this.type == 'xw' || this.type == 'hy' || this.type == 'hh') {
                    for (i = 0; i < num_classes; i++) {
                        tline = new TransferLine(this.type, this.layer, this.neuron, this, i)
                        tline.add()
                    }
                } else if (this.type == 'wxh') {
                    tline = new TransferLine(this.type, this.layer, this.neuron, this, 0)
                    tline.add()
                }
            }

            var tlines = [];
            var TransferLine = function(type, layer, neuron, set, index) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.set = set;
                this.index = index;
                this.source = set.source;
                this.target = set.target;
                tlines.push(this)
            }

            var transfer_line_function = d3.svg.line().interpolate("basis");

            TransferLine.prototype.add = function() {
                source_y = this.source.y_position
                target_y = this.target.y_position
                unit_offset = unit_height*this.index + unit_height/2
                switch(this.type) {
                    case 'hh': 
                        y_start = source_y + unit_height/2;
                        break;
                    case 'wxh':
                        y_start =  source_y + weight_set_height/2;
                        break
                    default:
                        y_start = source_y + unit_offset;
                        break;
                }
                full_transfer_width = (this.type == 'xw' || this.type == 'hy') ? (transfer_width + inner_margin) : 105;
                first_break = (this.type == 'xw') ? 1/4 : 2/3
                line_data = [
                    [0, y_start],
                    [full_transfer_width*first_break, y_start],
                    [3*full_transfer_width/4, target_y + unit_offset],
                    [full_transfer_width, target_y + unit_offset]
                ]
                this.set.d3_group.append("path")
                    .attr("d", transfer_line_function(line_data))
                    .attr('class', 'link')
                    .attr("stroke", medium_grey)
                    .attr("stroke-width", 2)//unit_height/2)
                    .attr('fill', 'none');  
            }

            add_network = function() {
                // add input units
                unitsets = [['input',0],['input',1],['output',0],['output',1],['target',0],['target',1]]
                for (i = 0; i < unitsets.length; i++) {
                   unitset = new UnitSet(unitsets[i][0], unitsets[i][1])
                   unitset.add()
                }

                for (layer_i = 0; layer_i < num_layers; layer_i++) {
                    for (neuron_i = 0; neuron_i < num_neurons; neuron_i++) {
                        neuron = new Neuron(layer_i, neuron_i);
                        neuron.add()

                        weight_types = ['xw', 'hy']
                        weight_types.forEach(function(type) {
                            weight_set = new WeightSet(type, layer_i, neuron_i);
                            weight_set.add()
                        })

                        hidden_state = new HiddenState(layer_i, neuron_i)
                        hidden_state.add()

                        transfer_line_types = ['xw', 'hh', 'hy']
                        transfer_line_types.forEach(function(type) {
                            tl_set = new TransferLineSet(type, layer_i, neuron_i)
                            tl_set.add()
                        });

                        tl_set = new TransferLineSet('wxh', layer_i, neuron_i)
                        tl_set.add()

                    }                    
                }
            };

            add_network()

            song_plot_group = svg.append("g")
                .attr("id", "song_plot_group")
                .attr("transform", "translate(0," + songs_bar_y_offset + ")")
            song_plot_yscale = d3.scale.linear().domain([0,num_classes]).range([0, song_plot_height])

            d3.range(0,num_classes).forEach(function(d) {
                song_plot_group.append("line")
                    .attr("x1", 0)
                    .attr("y1", song_plot_yscale(d))
                    .attr("x2", width)
                    .attr("y2", song_plot_yscale(d))
                    .attr("stroke", light_grey)
            })

            // function plot_song(song)
            song_plot_note_height = song_plot_height/num_classes
            d3.json("daft_punk-one_more_time.json", function(data) {
                seq_length = d3.max(data.map(function(d) { return d.seq_idx }))
                song_plot_note_width = song_plot_group_length/seq_length + 1
                xscale = d3.scale.linear().domain([0,seq_length]).range([0, song_plot_group_length])
                song_plot_group.selectAll('rect')
                    .data(data).enter()
                      .append('rect').attr('class', 'song_plot_unit')
                      .attr('x', function(d) { return xscale(d.seq_idx) })
                      .attr('y', function(d) { return song_plot_yscale(d.note) })
                      .attr('height', song_plot_note_height)
                      .attr('width', song_plot_note_width)
                      .attr('fill', function(d) { return kolors(d.note) })
            })

        </script>
    </footer>
</html>
