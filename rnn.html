<!DOCTYPE html>
<html>
    <meta charset="utf-8">
    <head>
        <style>
            body {
                /*background: #333;*/
            }
            #container {
                width: 1024px;
                display: block;
                margin: 40px auto;
            }

            .memory_cell {
                stroke: #ddd;
                stroke-width: 1px;
            }
            .link {
                /*visibility: hidden;*/
                stroke-width: 1px;
                stroke-dasharray: 10, 2;
                stroke: #ddd;
            }
            .unit {
                fill: white;
                stroke: #ddd;
            }

            marker {
                fill: #ddd;
                stroke-width: 0;
            }

            .flowline {
              stroke-dasharray: 10, 2;
              stroke-width: 2px;
              animation: flow 2s linear infinite;
              -webkit-animation: flow 2s linear infinite;
            }

            @keyframes flow {
              from {
                stroke-dashoffset: 12;
              }

              to {
                stroke-dashoffset: 0;
              }
            }

            @-webkit-keyframes flow {
              from {
                stroke-dashoffset: 12;
              }

              to {
                stroke-dashoffset: 0;
              }
            }
            .shadow {
                -webkit-svg-shadow: 0 0 7px #53BE12;
                /*-webkit-filter: drop-shadow( -2px -2px 2px #666 );
                        filter: drop-shadow( -2px -2px 2px #666 ); /* Same syntax as box-shadow */
            }
        </style>
        <!-- BOOTSTRAP LINKS -->
        <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <!-- jQuery library -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
        <!-- Latest compiled JavaScript -->
        <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>         
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    </head>


    <body>
        <div id="container">
            <div class="panel panel-default">
              <div class="panel-body">                  
                  <span id="info-text">Welcome to a <b>recurrent neural network!</b> We're going to train this network to create new music.</span>
                  &nbsp;
                  <button type="button" class="btn btn-success btn-sm" id="action-button">Setup Network</button>
              </div>
            </div>            
        </div>   
    </body>

    <footer>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src="javascripts/colorbrewer.min.js"></script>
        <script src="javascripts/underscore.js"></script>       
        <script>
            // LAYOUT
            var num_classes = 11,
                num_neurons = 2,
                num_layers = 2,
                width = 1024,
                height = 668, // height of whole container
                header_height = 0,
                unit_width = 20,
                unit_height = unit_width,
                transfer_width = 60,
                song_plot_height = 100,
                songs_bar_y_offset = height - song_plot_height,
                song_plot_width = width,
                inner_margin = 20,
                neuron_y_offset = 20,
                layer_width = width/2,
                neuron_width = (layer_width - 3*unit_width - 2*transfer_width - inner_margin),
                neuron_height = (height // height dynamically defined by other factors
                    - header_height
                    - 2*neuron_y_offset // offset from top and bottom of the network
                    - inner_margin*(num_neurons-1) // space between neurons in a layer
                    - song_plot_height)/num_neurons, // divide by number of neurons
                network_y_position = neuron_y_offset + header_height,
                weight_set_height = num_classes*unit_height,
                unit_set_y_position = network_y_position + (2*neuron_height + inner_margin)/2 - weight_set_height/2,
                light_grey = '#ededed',
                medium_grey = '#ccc',
                song_plot_note_height = song_plot_height/num_classes,
                layer1_visible = false,
                default_transition_duration = 200


            var kolors = d3.scale.ordinal()
                .domain(d3.range(0,num_classes))
                .range(colorbrewer.Spectral[num_classes]);

            var wkolors = d3.scale.linear()
                .domain([-1,0,1])
                .range(colorbrewer.Greys[4]);

            // FIX ME: need a better wait to fix the domain of this thing.
            // AND just colors in general
            var hskolors = d3.scale.linear()
                .domain([-1,0,1])
                .range(colorbrewer.Blues[5]);

            var svg = d3.select("#container").append("svg")           
                .attr("width", width+2)
                .attr("height", height)

            //svg.append('line').attr('x1', 1024/2).attr('x2', 1024/2).attr('y1', 0).attr('y2', 768).attr('stroke', 'black')
            layer0 = svg.append('g').attr('id', 'layer0')
            layer1 = svg.append('g').attr('id', 'layer1')

            var unit_sets = []
            var UnitSet = function(type, layer) {
                this.class = 'UnitSet';
                this.type = type;
                this.layer = layer;
                this.y_offset = unit_set_y_position;
                this.y_position = unit_set_y_position;
                this.values = _.map(_.range(0,num_classes), function(i) { return i*0 })
                unit_sets.push(this)
            }

            second_layer_visible = true;
            UnitSet.prototype.x_position = function() {
                var position = null;
                switch(this.type) {
                    case 'input':
                        // Not really sure about the second case, could be we use the output from layer 0
                        position = (this.layer == 0) ? 0 : layer_width;
                        break;
                    case 'output':
                        var layer_offset = unit_width + 2*transfer_width + neuron_width
                        position = (this.layer == 0) ? layer_offset : (layer_width + layer_offset)
                        break;
                    case 'target':
                        position = (this.layer == 0) ? (layer_width - unit_width) : (width - unit_width)
                        break;
                }
                return position;
            };

            var css_identifier = function(object_type, object_type_type, layer, neuron, index) {
                return object_type
                    + (object_type_type == null ? '' : '_' + object_type_type)
                    + (layer == null ? '' : '_L' + layer)
                    + (neuron == null ? '' : '_N' + neuron)
                    + (index == null ? '' : '_i' + index)
            }

            var layer_group = function(object) {
                return object.layer == 0 ? layer0 : layer1
            }
            UnitSet.prototype.add = function() {
                group = layer_group(this).append("g")
                    .attr("class", "unit_set")
                    .attr("id", css_identifier('unit_set', this.type, this.layer, null, null))
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_offset + ")")
                var layer = this.layer
                var type = this.type
                this.d3_group = group
                group.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', function(d, i) { return 'unit ' + css_identifier('unit', type, null, null, null) })
                        .attr('id', function(d, i) { return css_identifier('unit', type, layer, null, i) })
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})
            };

            var neurons = []
            Neuron = function(layer, index) {
                this.layer = layer;
                this.index = index;
                this.height = neuron_height;
                this.width = neuron_width
                neurons.push(this)
            }

            Neuron.prototype.y_position = function() {
                return (this.index == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin)
            }

            var neuron_x_offset = unit_width + transfer_width
            Neuron.prototype.x_position = function() {
                return (this.layer == 0) ? neuron_x_offset : (layer_width + neuron_x_offset)
            }

            Neuron.prototype.add = function() {
                group = layer_group(this).append("g")
                    .attr("class", "neuron")
                    .attr("id", css_identifier("neuron", null, this.layer, this.index, null))
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_position() + ")") 
                group.append('rect')
                    .attr('class', 'neuron_container')
                    .attr('width', neuron_width)
                    .attr('height', neuron_height)
                    .attr('fill', 'white')
                    .attr('stroke', medium_grey)
            }

            var weight_sets = []
            WeightSet = function(type, layer, neuron) {
                this.class = 'WeightSet';
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - weight_set_height)/2; // equally spaced from top and bottom of neuron container
                // FIXME: Hacky - duplicates code from Neuron#y_position
                this.y_position = this.y_offset + ((neuron == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin))
                weight_sets.push(this)
            }

            WeightSet.prototype.x_offset = function() {
                return (this.type == 'xw') ? inner_margin : (neuron_width - inner_margin - unit_width)
            }

            WeightSet.prototype.add = function() {
                var neuron = d3.select("#neuron_L" + this.layer + "_N" + this.neuron)
                var weight_set = neuron.append('g')
                                        .attr('class','weight_set')
                                        .attr('id', css_identifier('weight_set', this.type, this.layer, this.neuron, 0))
                                        .attr('transform', 'translate(' + this.x_offset() + ',' + this.y_offset + ')')
                this.d3_group = weight_set
                var layer = this.layer
                var type = this.type
                var neuron = this.neuron
                // DRY me with UnitSet#add
                weight_set.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', 'unit '
                            + function(d, i) { return css_identifier('weight', type, layer, neuron, null) })
                        .attr('id', function(d, i) { return css_identifier('weight', type, layer, neuron, i) })
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})
            }

            
            WeightSet.prototype.update_weights = function() {
                random_weights = _.map(_.range(0,num_classes), function() { return Math.random()*_.random(-1,1)})
                this.weights = random_weights
                this.d3_group.selectAll('rect')
                    .transition().duration(default_transition_duration)
                    .style('fill', function(d,i) { return wkolors(random_weights[i]) })
            }

            var hidden_states = []
            var HiddenState = function(layer, neuron) {
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - unit_height)/2;
                this.y_position = this.y_offset + network_y_position + (neuron == 1 ? (neuron_height + inner_margin) : 0);
                this.x_offset = (neuron_width - unit_width)/2;
                this.value = 0;
                this.input_weight_set = _.find(weight_sets, {layer: this.layer, neuron: this.neuron, type: 'xw'})
                this.output_weight_set = _.find(weight_sets, {layer: this.layer, neuron: this.neuron, type: 'hy'})                
                hidden_states.push(this)
            }

            HiddenState.prototype.add = function() {
                var neuron = d3.select("#neuron_L" + this.layer + "_N" + this.neuron)

                this.d3_unit = neuron.append('rect')
                                .attr('class', 'hidden_state unit')
                                .attr('id', css_identifier('hidden_state', null, this.layer, this.neuron, null))
                                .attr('width', unit_width)
                                .attr('height', unit_height)
                                .attr('x', this.x_offset)
                                .attr('y', this.y_offset)

                memory_cell = new MemoryCell(this, neuron);                                        
                memory_cell.add()
            }

            var vector_multiply = function(v1, v2) {
                // ASSERT EQUAL LENGTH
                sum = 0
                for (i = 0; i < v1.length; i ++) { sum += v1[i]*v2[i] }
                return sum
            }
            var notes_to_vector = function(notes) {
                return _.map(_.range(0, num_classes), function(i) {
                    return _.contains(notes, i) ? 1 : 0
                })
            }

            HiddenState.prototype.update = function() {
                weights = this.input_weight_set.weights

                notes = notes_to_vector(current_iter_notes.inputs)
                update_value = Math.tanh(vector_multiply(notes, weights))

                this.value = update_value
                this.d3_unit.transition()
                  .duration(default_transition_duration)
                  .style('fill', hskolors(this.value))
                outlines = _.where(tlines, {source: this})

                outlines.forEach(function(line) {
                    line.path.style('stroke', hskolors(update_value))
                    line.marker.style('fill', hskolors(update_value))
                })

            }

            memory_cells =[]
            var MemoryCell = function(hidden_state, neuron) {
                this.hidden_state = hidden_state
                this.neuron = neuron
                memory_cells.push(this)
            }

            MemoryCell.prototype.add = function() {
               // Memory cell top
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_top')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset - unit_width)
                    .attr('y2', this.hidden_state.y_offset - unit_width)

                // memory cell right top
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_right_top')
                    .attr('x1', this.hidden_state.x_offset + 2*unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset - unit_width)
                    .attr('y2', this.hidden_state.y_offset + unit_width/2)

                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_right_bottom')
                    .attr('x1', this.hidden_state.x_offset + 2*unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset + unit_width/2)
                    .attr('y2', this.hidden_state.y_offset + 2*unit_width)

                // memory cell bottom
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_bottom')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset + 2*unit_width)
                    .attr('y1', this.hidden_state.y_offset + 2*unit_width)
                    .attr('y2', this.hidden_state.y_offset + 2*unit_width)

                // memory cell left top
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_left_top')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset - unit_width)
                    .attr('y1', this.hidden_state.y_offset - unit_width)
                    .attr('y2', this.hidden_state.y_offset + unit_width/2)
                // memory cell left bottom
                this.neuron.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_left_bottom')
                    .attr('x1', this.hidden_state.x_offset - unit_width)
                    .attr('x2', this.hidden_state.x_offset - unit_width)
                    .attr('y1', this.hidden_state.y_offset + unit_width/2)
                    .attr('y2', this.hidden_state.y_offset + 2*unit_width)
            }

            MemoryCell.prototype.open = function(duration, side) {
                new_x = this.hidden_state.x_offset
                if (side == 'left') {
                    new_x += -unit_width - 3*unit_width/2
                } else {
                    new_x += 3*unit_width
                }
                //new_x = this.hidden_state.x_offset + 3*unit_width
                // fix me: this transition should not change length of line in the interim
                this.neuron.selectAll('.memory_cell_' + side + '_top').transition()
                    .ease('cubic')
                    .duration(duration/2)
                    .attr('x2', new_x)
                    .attr('y2', this.hidden_state.y_offset - unit_width)

                this.neuron.selectAll('.memory_cell_' + side + '_bottom').transition()
                    .duration(duration/2)
                    .ease('cubic')
                    .attr('x1', new_x)
                    .attr('y1', this.hidden_state.y_offset + 3*unit_width/2 + unit_width/2)
            }

            MemoryCell.prototype.close = function(duration, side) {
                new_x = this.hidden_state.x_offset
                if (side == 'left') {
                    new_x += -unit_width
                } else {
                    new_x += 2*unit_width
                }
                // fix me: this transition should not change length of line in the interim
                this.neuron.selectAll('.memory_cell_' + side + '_top').transition()
                    .duration(duration/2).delay(duration/2)
                    .attr('x2', new_x)
                    .attr('y2', this.hidden_state.y_offset + unit_width/2)

                this.neuron.selectAll('.memory_cell_' + side + '_bottom').transition()
                    .duration(duration/2).delay(duration/2)
                    .attr('x1', new_x)
                    .attr('y1', this.hidden_state.y_offset + unit_width/2)
            }

            var memory_cells_open_close = function(side, duration = default_transition_duration) {
                memory_cells.forEach(function(mc) {
                    mc.open(duration, side)
                })
                // memory_cells.forEach(function(mc) {
                //     mc.close(duration, side)
                // })
            }

            var tl_sets = [];
            var TransferLineSet = function(type, layer, neuron) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;

                switch(type) {
                    case 'xw':    
                        this.source = _.findWhere(unit_sets, {type: 'input', layer: layer})
                        this.target = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        break;
                    case 'wxh':
                        this.source = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        this.target = _.findWhere(hidden_states, {layer: layer, neuron: neuron})
                        break;
                    case 'hh':
                        this.source = _.findWhere(hidden_states, {layer: layer, neuron: neuron})
                        this.target = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        break;
                    case 'hy':
                        this.source = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        this.target = _.findWhere(unit_sets, {type: 'output', layer: layer})
                        break;
                }
                tl_sets.push(this)
            }

            TransferLineSet.prototype.x_offset = function() {
                var x_offset = null;
                switch(this.type) {
                    case 'xw':
                        x_offset = (this.layer == 0) ? unit_width : (layer_width + unit_width);
                        break;
                    case 'wxh':
                        layer_wxh_offset = 2*unit_width + transfer_width + inner_margin;
                        x_offset = (this.layer == 0) ? layer_wxh_offset : layer_width + layer_wxh_offset;
                        break;
                    case 'hh':
                        layer_hh_offset = unit_width + transfer_width + neuron_width/2 + unit_width/2;
                        x_offset = (this.layer == 0) ? layer_hh_offset : layer_width + layer_hh_offset;
                        break;
                    case 'hy':
                        x_offset = (this.layer == 0) ? (transfer_width + neuron_width) : (layer_width + transfer_width + neuron_width);
                        break;
                }
                return x_offset;
            }

            TransferLineSet.prototype.add = function() {
                // add a group with x offset
                group = layer_group(this).append('g')
                           .attr('class', 'tl_set')
                           .attr('id', css_identifier('tl_set', this.type, this.layer, this.neuron, null))
                           .attr('transform', 'translate(' + this.x_offset() + ',0)')
                this.d3_group = group;
                // add a transfer line for every class in num_classes
                //if (this.type == 'xw' || this.type == 'hy' || this.type == 'hh') {
                    for (i = 0; i < num_classes; i++) {
                        tline = new TransferLine(this.type, this.layer, this.neuron, this, i)
                        tline.add()
                    }
                // } else if (this.type == 'wxh') {
                //     tline = new TransferLine(this.type, this.layer, this.neuron, this, 0)
                //     tline.add()
                // }
            }

            var tlines = [];
            var TransferLine = function(type, layer, neuron, set, index) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.set = set;
                this.index = index;
                this.source = set.source;
                this.target = set.target;
                tlines.push(this)
            }

            var transfer_line_function = d3.svg.line().interpolate("basis");

            var transfer_line_data = function(transfer_line, state) {
                unit_offset = unit_height*transfer_line.index + unit_height/2

                source_y = transfer_line.source.y_position
                target_y = transfer_line.target.y_position

                target_y = transfer_line.type == 'wxh' ? target_y + unit_height/2 : target_y + unit_offset
                y_start = source_y + (transfer_line.type == 'hh' ? unit_height/2 : unit_offset)
                // FIXME: The 105 is pixel-fixing
                full_transfer_width = (transfer_line.type == 'xw' || transfer_line.type == 'hy') ? (transfer_width + inner_margin) : 105;
                first_break = 1/4

                if (state == 'grow') {
                    line_data = [
                        [0, y_start],
                        [full_transfer_width*first_break, y_start],
                        [full_transfer_width*(1-first_break), target_y],
                        [full_transfer_width - 6, target_y]
                    ]                    
                } else if (state == 'init') {
                    line_data = [
                        [0, y_start],
                        [0, y_start],
                        [0, y_start],
                        [0, y_start]
                    ]                     
                }
                return line_data
            }
            TransferLine.prototype.add = function() {
                // FIXME: Not DRY
                marker_id = css_identifier('marker', this.type, this.layer, this.neuron, this.index)
                marker = svg.append("defs").append("marker")
                    .attr("id", marker_id)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 2)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                  .append("path")
                    .attr("d", "M0,-5L10,0L0,5");
                this.marker = marker                       
                path = this.set.d3_group.append("path")
                        .attr("d", transfer_line_function(transfer_line_data(this, 'init')))
                        .attr('class', 'link')
                        .attr("stroke", medium_grey)
                        .attr('fill', 'none')
                        .attr('visibility', 'hidden')
                        .attr("marker-end", 'url(#' + marker_id + ')');
                this.path = path; 
            }

            TransferLine.prototype.grow = function(duration = default_transition_duration, delay = 0) {
                this.path.attr('visibility', 'visible')
                  .transition().duration(duration).delay(delay)
                  .attr('d', transfer_line_function(transfer_line_data(this, 'grow')))
            }

            add_network = function() {
                // add input units
                unitsets = [['input',0],['input',1],['output',0],['output',1],['target',0],['target',1]]
                for (i = 0; i < unitsets.length; i++) {
                   unitset = new UnitSet(unitsets[i][0], unitsets[i][1])
                   unitset.add()
                }

                for (layer_i = 0; layer_i < num_layers; layer_i++) {
                    for (neuron_i = 0; neuron_i < num_neurons; neuron_i++) {
                        neuron = new Neuron(layer_i, neuron_i);
                        neuron.add()

                        weight_types = ['xw', 'hy']
                        weight_types.forEach(function(type) {
                            weight_set = new WeightSet(type, layer_i, neuron_i);
                            weight_set.add()
                        })

                        hidden_state = new HiddenState(layer_i, neuron_i)
                        hidden_state.add()

                        transfer_line_types = ['xw', 'hh', 'hy', 'wxh']
                        transfer_line_types.forEach(function(type) {
                            tl_set = new TransferLineSet(type, layer_i, neuron_i)
                            tl_set.add()
                        });

                    }    
                }
            };

            add_network()


            // Song Stuff
            song_plot_group = svg.append("g")
                .attr("id", "song_plot_group")
                .attr("transform", "translate(0," + songs_bar_y_offset + ")")
            song_plot_yscale = d3.scale.linear().domain([0,num_classes]).range([0, song_plot_height])

            d3.range(0,num_classes).forEach(function(d) {
                song_plot_group.append("line")
                    .attr("x1", 0)
                    .attr("y1", song_plot_yscale(d))
                    .attr("x2", width)
                    .attr("y2", song_plot_yscale(d))
                    .attr("stroke", light_grey)
            })

            var songs = []
            var current_song = null

            var iter_note_sets = []
            var IterNoteSet = function(song, inputs, targets, iter_index) {
                this.song = song;
                this.inputs = inputs;
                this.targets = targets;
                this.iter_index = iter_index;
                iter_note_sets.push(this)
            }

            var Song = function(filename) {
                this.filename = filename;
                this.song_data = null;
                this.sequence_length = null;
                this.note_width = null;
                this.song_input_unit_path = null;
                this.song_target_unit_path = null;
                this.d3_notes = null;
                // function plot_song(song)
                var song = this
                d3.json(filename, function(data) {
                    song.raw_song_data = data;
                    song.song_data = []
                    data.forEach(function(notes, i) {
                        notes.forEach(function(note){
                            song.song_data.push({note: note, seq_idx: i})
                        })
                    })
                    song.sequence_length = data.length;
                    song.note_width = song_plot_width/song.sequence_length + 0.5 // width of each note plotted (e.g. 16th note)

                    // for every index in the total sequence, add an iter_note_set
                    data.forEach(function(notes, i) {
                        iter_note_set = new IterNoteSet(song, notes, data[i+1], i)
                    })                    
                })
            }

            //Song.prototype.xscale = d3.scale.linear().domain([0, this.sequence_length]).range([0, song_plot_width])

            Song.prototype.plot = function() {
                // scale from width of plot to seq length
                var xscale = d3.scale.linear().domain([0, this.sequence_length]).range([0, song_plot_width]);

                this.d3_notes = song_plot_group.selectAll('rect')
                                    .data(this.song_data).enter()
                                      .append('rect').attr('class', 'song_plot_unit')
                                      .attr('x', function(d,i) { return xscale(d.seq_idx) + song_plot_width + 2 })
                                      .attr('y', function(d) { return song_plot_yscale(d.note) })
                                      .attr('height', song_plot_note_height)
                                      .attr('width', this.note_width)
                                      .attr('fill', function(d) { return kolors(d.note) })                
            }

            Song.prototype.shift = function(iter_index, duration = default_transition_duration) {
                var xscale = d3.scale.linear().domain([0, this.sequence_length]).range([0, song_plot_width]);
                this.d3_notes.transition().duration(duration)
                     .attr('x', function(d) { return xscale(d.seq_idx) + width/2 - xscale(iter_index) })
            }

            Song.prototype.draw_song_unit_line = function(type, state, duration = default_transition_duration) {
                // draw lines from song to input or target
                input_note_offset = (type == 'input' ? 0 : this.note_width) + song_plot_width/2
                input_song_x = input_note_offset + this.note_width/2
                input_input_x = (layer1_visible ? 0 : layer_width/2) 
                    + (type == 'input' ? unit_width/2 : (layer_width - unit_width/2))
                input_song_y = height - song_plot_height
                input_input_y = unit_set_y_position + weight_set_height

                if (state == 'grow') {
                    input_line_data = [
                        [input_song_x, input_song_y],
                        [input_song_x, input_song_y - (input_song_y - input_input_y)/4],
                        [input_input_x, input_song_y - 3*(input_song_y - input_input_y)/4],
                        [input_input_x, input_input_y + 6] // plus 6 for the arrow
                    ]
                    if (type == 'input') {
                        this.song_input_unit_path.transition()
                            .duration(duration).attr('d', transfer_line_function(input_line_data))
                            .attr('class', 'flowline')                            
                    } else {
                        this.song_target_unit_path.transition()
                            .duration(duration).attr('d', transfer_line_function(input_line_data))
                            .attr('class', 'flowline')
                    }
                    
                } else if (state == 'init') {
                    marker_id = css_identifier('marker', type, null, null, null)
                    svg.append("defs").append("marker")
                        .attr("id", marker_id)
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 2)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                      .append("path")
                        .attr("d", "M0,-5L10,0L0,5");                    
                    input_line_data = [
                        [input_song_x, input_song_y],
                        [input_song_x, input_song_y],
                        [input_song_x, input_song_y],
                        [input_song_x, input_song_y]
                    ]
                    path = svg.append('path')
                        .attr("d", transfer_line_function(input_line_data))
                        .attr('class', 'link')
                        .attr("stroke", medium_grey)
                        .attr('fill', 'none')
                        .attr("marker-end", "url(#" + marker_id + ")"); 
                    if (type == 'input') {
                        this.song_input_unit_path = path
                    } else {
                        this.song_target_unit_path = path
                    }
                }                        
            }

            var ascender_height = 6,
                descender_height = 1
            Song.prototype.init_pointers = function() {
                pointers = ['t', 'between','tplus1']
                song = this
                pointers.forEach(function(pointer_type) {
                    var x1 = 1,
                        x2 = 1
                    if (pointer_type == 'between') {
                        x1 = song.note_width
                        x2 = song.note_width
                    } else if (pointer_type == 'tplus1') {
                        x1 = 2*song.note_width
                        x2 = 2*song.note_width
                    }
                    song_plot_group.append('line')
                      .attr('class', 'song_bar_pointer')
                      .attr('id', 'song_bar_' + pointer_type + '_pointer')
                      .attr('x1', x1 + song_plot_width/2)
                      .attr('y1', song_plot_height + descender_height)
                      .attr('x2', x2 + song_plot_width/2)
                      .attr('y2', -ascender_height)
                      .attr('stroke', medium_grey)
                })
                
                this.draw_song_unit_line('input', 'init')  
                this.draw_song_unit_line('target', 'init')

                song_plot_group.append('rect')
                    .attr('x',0)
                    .attr('y', -ascender_height)
                    .attr('width', song_plot_width/2)
                    .attr('height', song_plot_height + ascender_height)
                    .attr('fill', light_grey)
                    .attr('opacity', 0.5)
            }
            var song = new Song('daft_punk-one_more_time.json')

            // initial state stuff
            if (!layer1_visible) {
                d3.select('#layer1').selectAll('*').style('visibility', 'hidden')
                d3.select('#layer0').attr('transform', 'translate(' + layer_width/2 + ',0)')
            }

            var color_units = function(iter_notes, type) {
                notes = (type == 'input') ? iter_notes.inputs : iter_notes.targets
                d3.selectAll('.unit_' + type).style('fill','white')
                notes.forEach(function(ui) {
                    identifier = '#' + css_identifier('unit', type, 0, null, ui)
                    input_unit = d3.select(identifier)
                    input_unit.transition()
                        .duration(default_transition_duration).delay(default_transition_duration).style('fill', kolors(ui))
                })          
            }

            var current_iter = 0
            var current_iter_notes = iter_note_sets[current_iter]
            var update_current_iter = function() {
                current_iter += 1
                current_iter_notes[current_iter]
            }

            var sub_iter0 = function() {
                song.shift(current_iter)
                current_iter_notes = iter_note_sets[current_iter]
                color_units(current_iter_notes, 'input')
                color_units(current_iter_notes, 'target')                
            }

            var sub_iter1 = function() {
                reset_lines('xw')
                xw_lines = _.filter(tlines, function(line) { return line.type == 'xw' })

                notes = current_iter_notes.inputs
                current_iter_lines = _.filter(xw_lines, function(line) { return _.contains(notes, line.index) })
                current_iter_lines.forEach(function(line) {
                    line.path.transition().duration(default_transition_duration).delay(default_transition_duration)
                        .attr('stroke', kolors(line.index))
                        .attr('class', 'flowline')
                    line.marker
                        .transition().duration(default_transition_duration).delay(default_transition_duration)
                        .style('fill', kolors(line.index))
                })                
            }

            var sub_iter2 = function() {
                reset_lines('wxh')
                wxh_lines = _.filter(tlines, function(line) { return line.type == 'wxh' })
                wxh_lines.forEach(function(tl) {                 
                    activated = _.contains(current_iter_notes.inputs, tl.index)
                    if (activated) {
                        tl.path.transition().duration(default_transition_duration).delay(default_transition_duration)
                          .attr('class', 'flowline')
                          .attr('stroke', kolors(tl.index))
                          .attr('opacity', Math.max(0.5, Math.abs(tl.source.weights[tl.index])))
                        tl.marker.transition().duration(default_transition_duration).delay(default_transition_duration)
                          .style('fill', kolors(tl.index))
                          .attr('opacity', Math.max(0.5, Math.abs(tl.source.weights[tl.index])))
                    }
                })
                hidden_states.forEach(function(hs) { hs.update() })                
            }

            //updating of the lines is done in hs.update()            
            var sub_iter3 = function() {}

            var sub_iter4 = function() {
                hy_lines = _.filter(tlines, function(line) { return line.type == 'hy' })
                hy_lines.forEach(function(tl) {
                    weight = tl.source.weights[tl.index]
                    hidden_state = _.find(hidden_states, {layer: tl.layer, neuron: tl.neuron})
                    prob = weight*hidden_state.value
                    tl.value = prob
                    tl.path.transition().duration(default_transition_duration).delay(default_transition_duration)
                      .attr('class', 'flowline')
                    tl.path.attr('stroke', wkolors(prob))
                    tl.marker.style('fill', wkolors(prob))
                })

                output_unit_sets = _.filter(unit_sets, function(us) { return us.type == 'output' })

                output_unit_sets.forEach(function(us) {
                    lines = _.where(tlines, {layer: us.layer, type: 'hy'})
                    
                    us.d3_group.selectAll('.unit')
                      .style('fill', function(d, i) { return kolors(i)})
                      .attr('fill-opacity', function(d, i) {
                            this_probs = _.map(_.where(lines, {index: i}), function(l) { return l.value })
                            total_prob = _.reduce(this_probs, function(memo, num) { return memo + num })
                            console.log(total_prob)
                            return Math.max(0.15, total_prob)
                      })
                })
            }

            var iter = function() {
                update_current_iter()
                sub_iter0()
                sub_iter1()
                sub_iter2()
                sub_iter3()
                sub_iter4()
            }

            var reset_lines = function(type) {
                lines = _.filter(tlines, function(line) { return line.type == type })
                lines.forEach(function(tl) {
                    tl.path.classed('flowline', false)
                    tl.path.classed('link', true)
                    tl.marker.style('fill', '#ddd')                     
                })
            }

            var current_state = 'entered'
            $('#action-button').on('click', function() {
                if (current_state == 'entered') {
                    $('#info-text').html("The first step is to gather the training data and initialize random weights. Now we're ready to start training!")
                    $('#action-button').html("First step: Input song")

                    song.plot()

                    weight_sets.forEach(function(set) {
                        set.update_weights();
                    })

                    current_state = 'network_setup'
                } else if (current_state == 'network_setup') {
                    $('#info-text').html("In the first iteration, the input is the first note and the target is the second note.")
                    $('#action-button').html("Next Step")
                    song.init_pointers()

                    song.draw_song_unit_line('input', 'grow')
                    song.draw_song_unit_line('target', 'grow')

                    sub_iter0()
 
                    current_state = 'sub_iter0'
                } else if (current_state == 'sub_iter0') {
                    $('#info-text').html("The input is multiplied by the current set of weights.")
                    xw_lines = _.filter(tlines, function(line) { return line.type == 'xw' })
                    xw_lines.forEach(function(tl) { return tl.grow() })                    
                    sub_iter1()
                    current_state = 'sub_iter1'
                } else if (current_state == 'sub_iter1') {
                    $('#info-text').html("The weighted sum is then passed to the 'memory' cell. This is the <b>magic of a recurrent neural network</b>")
                    wxh_lines = _.filter(tlines, function(line) { return line.type == 'wxh' })
                    wxh_lines.forEach(function(tl) {
                        memory_cells_open_close('left')
                        tl.grow()
                    })
                    sub_iter2()
                    current_state = 'sub_iter2'
                } else if (current_state == 'sub_iter2') {
                    $('#info-text').html("The memory cell stores the information in the <b>hidden state</b> which can be recalled on the next iteration.")
                    hh_lines = _.filter(tlines, function(line) { return line.type == 'hh' })
                    hh_lines.forEach(function(tl) {
                        memory_cells_open_close('right')
                        tl.grow()
                        tl.path.transition().duration(default_transition_duration).delay(default_transition_duration)
                          .attr('class', 'flowline')
                    })
                    sub_iter3()
                    current_state = 'sub_iter3'
                } else if (current_state == 'sub_iter3') {
                    $('#info-text').html("Finally, the hidden state is multiplied by an output set of weights, which formulates the probability of each note following the current note.")
                    hy_lines = _.filter(tlines, function(line) { return line.type == 'hy' })
                    hy_lines.forEach(function(tl) {
                        tl.grow()
                    })
                    sub_iter4()
                    current_state = 'sub_iter4'                    
                }
            })
            
        </script>
    </footer>
</html>
