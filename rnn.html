<!DOCTYPE html>
<html>
    <meta charset="utf-8">
    <head>
        <!-- BOOTSTRAP LINKS -->
        <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <!-- jQuery library -->
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js"></script>
        <!-- Latest compiled JavaScript -->
        <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>         
        <style>
            body {
                /*background: #333;*/
                font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
                font-weight: 200;
            }
            #container {
                width: 1024px;
                display: block;
                margin: 40px auto;
            }

            svg {
                padding-top: 12px; /*protects our labels*/
            }

            .memory_cell {
                stroke: #ddd;
                stroke-width: 1px;
            }
            .link {
                /*visibility: hidden;*/
                stroke-width: 1px;
                stroke-dasharray: 10, 2;
                stroke: #ddd;
            }
            .unit {
                fill: white;
                stroke: #ddd;
            }

            marker {
                fill: #ddd;
                stroke-width: 0;
            }

            .flowline, .flowline-reverse {
              stroke-dasharray: 10, 2;
              stroke-width: 2px;
              animation: flow 2s linear infinite;
              -webkit-animation: flow 2s linear infinite;
            }

            .flowline-reverse {
              animation: flowreverse 2s linear infinite !important;
              -webkit-animation: flowreverse 2s linear infinite !important;
            }            

            @keyframes flow {
              from {
                stroke-dashoffset: 12;
              }

              to {
                stroke-dashoffset: 0;
              }
            }

            @-webkit-keyframes flow {
              from {
                stroke-dashoffset: 12;
              }

              to {
                stroke-dashoffset: 0;
              }
            }

            @keyframes flowreverse {
              from {
                stroke-dashoffset: 0;
              }

              to {
                stroke-dashoffset: 12;
              }
            }

            @-webkit-keyframes flowreverse {
              from {
                stroke-dashoffset: 0;
              }

              to {
                stroke-dashoffset: 12;
              }
            }
  
            .nav-tabs {
                float: right;
                width: 44%;
                font-size: 10px;
                margin-top: 20px;
            }

            .nav-tabs li {
                float: right;
            }

        </style>    
        <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css">
    </head>


    <body>
        <div id="container">
            <ul class="nav nav-tabs">
              <li><a href="#">Create</a></li>
              <li class="active"><a href="#">Train</a></li>              
              <li><a href="#">What is a neural network?</a></li>
              <li><a href="#">What is a neuron?</a></li>              
              <li><a href="#">Home</a></li>              
            </ul>        
            <!-- Information Panel -->
            <div class="panel panel-default" style="width: 54%; position: relative; height: 100px;">
              <div class="panel-body">                  
                  <span id="info-text">Welcome to a <b>recurrent neural network!</b> Here, we're going to train a network to create new music.</span>
                  &nbsp;
                  <button type="button" class="btn btn-success btn-sm" id="action-button" style="position: absolute; right: 20px; bottom:20px;">Setup Network</button>
              </div>
            </div>                   
        </div>   
    </body>

    <footer>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src="javascripts/colorbrewer.min.js"></script>
        <script src="javascripts/underscore.js"></script>       
        <script>
            // LAYOUT
            var num_classes = 11,
                num_neurons = 2,
                num_layers = 2,
                width = 1024,
                height = 668, // height of whole container
                header_height = 0,
                unit_width = 20,
                unit_height = unit_width,
                transfer_width = 60,
                song_plot_height = 100,
                songs_bar_y_offset = height - song_plot_height,
                song_plot_width = width,
                inner_margin = 20,
                neuron_y_offset = 20,
                layer_width = width/2,
                neuron_width = (layer_width - 3*unit_width - 2*transfer_width - inner_margin),
                neuron_height = (height // height dynamically defined by other factors
                    - header_height
                    - 2*neuron_y_offset // offset from top and bottom of the network
                    - inner_margin*(num_neurons-1) // space between neurons in a layer
                    - song_plot_height)/num_neurons, // divide by number of neurons
                network_y_position = neuron_y_offset + header_height,
                weight_set_height = num_classes*unit_height,
                unit_set_y_position = network_y_position + (2*neuron_height + inner_margin)/2 - weight_set_height/2,
                light_grey = '#ededed',
                medium_grey = '#ccc',
                song_plot_note_height = song_plot_height/num_classes,
                layer1_visible = true,
                default_sub_iter_duration = 1000


            var kolors = d3.scale.ordinal()
                .domain(d3.range(0,num_classes))
                .range(colorbrewer.Spectral[num_classes]);

            var wkolors = d3.scale.linear()
                .domain([-1,0,1])
                .range(colorbrewer.Greys[4]);

            // FIX ME: need a better wait to fix the domain of this thing.
            // AND just colors in general
            var hskolors = d3.scale.linear()
                .domain([-1,0,1])
                .range(colorbrewer.Blues[5]);

            var svg = d3.select("#container").append("svg")           
                .attr("width", width+2)
                .attr("height", height)

            //svg.append('line').attr('x1', 1024/2).attr('x2', 1024/2).attr('y1', 0).attr('y2', 768).attr('stroke', 'black')
            layer0 = svg.append('g').attr('id', 'layer0')
            layer1 = svg.append('g').attr('id', 'layer1')

            var unit_sets = []
            var UnitSet = function(type, layer) {
                this.class = 'UnitSet';
                this.type = type;
                this.layer = layer;
                this.y_offset = unit_set_y_position;
                this.y_position = unit_set_y_position;
                this.values = _.map(_.range(0,num_classes), function(i) { return i*0 })
                unit_sets.push(this)
            }

            second_layer_visible = true;
            UnitSet.prototype.x_position = function() {
                var position = null;
                switch(this.type) {
                    case 'input':
                        // Not really sure about the second case, could be we use the output from layer 0
                        position = (this.layer == 0) ? 0 : layer_width;
                        break;
                    case 'output':
                        var layer_offset = unit_width + 2*transfer_width + neuron_width
                        position = (this.layer == 0) ? layer_offset : (layer_width + layer_offset)
                        break;
                    case 'target':
                        position = (this.layer == 0) ? (layer_width - unit_width) : (width - unit_width)
                        break;
                }
                return position;
            };

            var css_identifier = function(object_type, object_type_type, layer, neuron, index) {
                return object_type
                    + (object_type_type == null ? '' : '_' + object_type_type)
                    + (layer == null ? '' : '_L' + layer)
                    + (neuron == null ? '' : '_N' + neuron)
                    + (index == null ? '' : '_i' + index)
            }

            var layer_group = function(object) {
                return object.layer == 0 ? layer0 : layer1
            }
            UnitSet.prototype.add = function() {
                group = layer_group(this).append("g")
                    .attr("class", "unit_set")
                    .attr("id", css_identifier('unit_set', this.type, this.layer, null, null))
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_offset + ")")
                var layer = this.layer
                var type = this.type
                this.d3_group = group
                group.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', function(d, i) { return 'unit ' + css_identifier('unit', type, null, null, null) })
                        .attr('id', function(d, i) { return css_identifier('unit', type, layer, null, i) })
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})
            };

            var neurons = []
            Neuron = function(layer, index) {
                this.layer = layer;
                this.index = index;
                this.height = neuron_height;
                this.width = neuron_width
                neurons.push(this)
            }

            Neuron.prototype.y_position = function() {
                return (this.index == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin)
            }

            var neuron_x_offset = unit_width + transfer_width
            Neuron.prototype.x_position = function() {
                return (this.layer == 0) ? neuron_x_offset : (layer_width + neuron_x_offset)
            }

            Neuron.prototype.add = function() {
                this.group = layer_group(this).append("g")
                    .attr("class", "neuron")
                    .attr("id", css_identifier("neuron", null, this.layer, this.index, null))
                    .attr("transform", "translate(" + this.x_position() + "," + this.y_position() + ")") 
                this.group.append('rect')
                    .attr('class', 'neuron_container')
                    .attr('width', neuron_width)
                    .attr('height', neuron_height)
                    .attr('fill', 'white')
                    .attr('stroke', medium_grey)
            }

            var weight_sets = []
            WeightSet = function(type, layer, neuron) {
                this.class = 'WeightSet';
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - weight_set_height)/2; // equally spaced from top and bottom of neuron container
                // FIXME: Hacky - duplicates code from Neuron#y_position
                this.y_position = this.y_offset + ((neuron == 0) ? network_y_position : (network_y_position + neuron_height + inner_margin))
                weight_sets.push(this)
            }

            WeightSet.prototype.x_offset = function() {
                return (this.type == 'xw') ? inner_margin : (neuron_width - inner_margin - unit_width)
            }

            WeightSet.prototype.add = function() {
                var neuron = d3.select("#neuron_L" + this.layer + "_N" + this.neuron)
                var weight_set = neuron.append('g')
                                        .attr('class','weight_set')
                                        .attr('id', css_identifier('weight_set', this.type, this.layer, this.neuron, 0))
                                        .attr('transform', 'translate(' + this.x_offset() + ',' + this.y_offset + ')')
                this.d3_group = weight_set
                var layer = this.layer
                var type = this.type
                var neuron = this.neuron
                // DRY me with UnitSet#add
                weight_set.selectAll('rect')
                    .data(d3.range(0,num_classes))
                    .enter().append('rect')
                        .attr('class', 'unit '
                            + function(d, i) { return css_identifier('weight', type, layer, neuron, null) })
                        .attr('id', function(d, i) { return css_identifier('weight', type, layer, neuron, i) })
                        .attr('width', unit_width)
                        .attr('height', unit_height)
                        .attr('y', function(d, i) { return i*unit_height})
            }

            
            WeightSet.prototype.update_weights = function() {
                random_weights = _.map(_.range(0,num_classes), function() { return Math.random()*_.random(-1,1)})
                this.weights = random_weights
                this.d3_group.selectAll('rect')
                    .transition().duration(default_sub_iter_duration)
                    .style('fill', function(d,i) { return wkolors(random_weights[i]) })
            }

            var hidden_states = []
            var HiddenState = function(layer, neuron) {
                this.layer = layer;
                this.neuron = neuron;
                this.y_offset = (neuron_height - unit_height)/2;
                this.y_position = this.y_offset + network_y_position + (neuron == 1 ? (neuron_height + inner_margin) : 0);
                this.x_offset = (neuron_width - unit_width)/2;
                this.value = 0;
                this.input_weight_set = _.find(weight_sets, {layer: this.layer, neuron: this.neuron, type: 'xw'})
                this.output_weight_set = _.find(weight_sets, {layer: this.layer, neuron: this.neuron, type: 'hy'})                
                hidden_states.push(this)
            }

            HiddenState.prototype.add = function() {
                var neuron = d3.select("#neuron_L" + this.layer + "_N" + this.neuron)

                this.d3_unit = neuron.append('rect')
                                .attr('class', 'hidden_state unit')
                                .attr('id', css_identifier('hidden_state', null, this.layer, this.neuron, null))
                                .attr('width', unit_width)
                                .attr('height', unit_height)
                                .attr('x', this.x_offset)
                                .attr('y', this.y_offset)

                memory_cell = new MemoryCell(this, neuron);                                        
                memory_cell.add()
            }

            var vector_multiply = function(v1, v2) {
                // ASSERT EQUAL LENGTH
                sum = 0
                for (i = 0; i < v1.length; i ++) { sum += v1[i]*v2[i] }
                return sum
            }
            var notes_to_vector = function(notes) {
                return _.map(_.range(0, num_classes), function(i) {
                    return _.contains(notes, i) ? 1 : 0
                })
            }

            HiddenState.prototype.update = function(delay = default_sub_iter_duration) {
                weights = this.input_weight_set.weights

                notes = notes_to_vector(current_iter_notes.inputs)
                update_value = Math.tanh(vector_multiply(notes, weights))

                this.value = update_value
                this.d3_unit.transition()
                  .duration(default_sub_iter_duration)
                  .delay(delay)
                  .style('fill', hskolors(this.value))
                outlines = _.where(tlines, {source: this})

                outlines.forEach(function(line) {
                    line.path.style('stroke', hskolors(update_value))
                    line.marker.style('fill', hskolors(update_value))
                })

            }

            memory_cells =[]
            var MemoryCell = function(hidden_state, neuron) {
                this.hidden_state = hidden_state
                this.neuron = neuron
                this.layer = hidden_state.layer
                memory_cells.push(this)
            }

            MemoryCell.prototype.add = function() {
                mc_group = this.neuron.append('g').attr('class','memory_cell_group')
                    .attr('transform', 'translate(' + this.hidden_state.x_offset + ',' + this.hidden_state.y_offset + ')')
                this.d3_group = mc_group
                // Memory cell top
                mc_group.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_top')
                    .attr('x1', - unit_width)
                    .attr('x2', + 2*unit_width)
                    .attr('y1', - unit_width)
                    .attr('y2', - unit_width)

                // memory cell right top
                mc_group.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_right_top')
                    .attr('x1', + 2*unit_width)
                    .attr('x2', + 2*unit_width)
                    .attr('y1', - unit_width)
                    .attr('y2', + unit_width/2)

                mc_group.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_right_bottom')
                    .attr('x1', + 2*unit_width)
                    .attr('x2', + 2*unit_width)
                    .attr('y1', + unit_width/2)
                    .attr('y2', + 2*unit_width)

                // memory cell bottom
                mc_group.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_bottom')
                    .attr('x1', - unit_width)
                    .attr('x2', + 2*unit_width)
                    .attr('y1', + 2*unit_width)
                    .attr('y2', + 2*unit_width)

                // memory cell left top
                mc_group.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_left_top')
                    .attr('x1', - unit_width)
                    .attr('x2', - unit_width)
                    .attr('y1', - unit_width)
                    .attr('y2', + unit_width/2)
                // memory cell left bottom
                mc_group.append('svg:line')
                    .attr('class', 'memory_cell memory_cell_left_bottom')
                    .attr('x1', - unit_width)
                    .attr('x2', - unit_width)
                    .attr('y1', + unit_width/2)
                    .attr('y2', + 2*unit_width)
            }

            MemoryCell.prototype.open = function(duration, side) {
                new_x = 0
                if (side == 'left') {
                    new_x += -unit_width - 3*unit_width/2
                } else {
                    new_x += 3*unit_width
                }
                //new_x = this.hidden_state.x_offset + 3*unit_width
                // fix me: this transition should not change length of line in the interim
                this.neuron.selectAll('.memory_cell_' + side + '_top').transition()
                    .ease('cubic')
                    .duration(duration/2)
                    .attr('x2', new_x)
                    .attr('y2', -unit_width)

                this.neuron.selectAll('.memory_cell_' + side + '_bottom').transition()
                    .duration(duration/2)
                    .ease('cubic')
                    .attr('x1', new_x)
                    .attr('y1', 3*unit_width/2 + unit_width/2)
            }

            var memory_cells_open_close = function(side, layer, duration = default_sub_iter_duration) {
                _.where(memory_cells, {layer: layer}).forEach(function(mc) {
                    mc.open(duration, side)
                })
            }

            var tl_sets = [];
            var TransferLineSet = function(type, layer, neuron) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;

                switch(type) {
                    case 'xw':    
                        this.source = _.findWhere(unit_sets, {type: 'input', layer: layer})
                        this.target = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        break;
                    case 'wxh':
                        this.source = _.findWhere(weight_sets, {type: 'xw', layer: layer, neuron: neuron})
                        this.target = _.findWhere(hidden_states, {layer: layer, neuron: neuron})
                        break;
                    case 'hh':
                        this.source = _.findWhere(hidden_states, {layer: layer, neuron: neuron})
                        this.target = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        break;
                    case 'hy':
                        this.source = _.findWhere(weight_sets, {type: 'hy', layer: layer, neuron: neuron})
                        this.target = _.findWhere(unit_sets, {type: 'output', layer: layer})
                        break;
                }
                tl_sets.push(this)
            }

            TransferLineSet.prototype.x_offset = function() {
                var x_offset = null;
                switch(this.type) {
                    case 'xw':
                        x_offset = (this.layer == 0) ? unit_width : (layer_width + unit_width);
                        break;
                    case 'wxh':
                        layer_wxh_offset = 2*unit_width + transfer_width + inner_margin;
                        x_offset = (this.layer == 0) ? layer_wxh_offset : layer_width + layer_wxh_offset;
                        break;
                    case 'hh':
                        layer_hh_offset = unit_width + transfer_width + neuron_width/2 + unit_width/2;
                        x_offset = (this.layer == 0) ? layer_hh_offset : layer_width + layer_hh_offset;
                        break;
                    case 'hy':
                        x_offset = (this.layer == 0) ? (transfer_width + neuron_width) : (layer_width + transfer_width + neuron_width);
                        break;
                }
                return x_offset;
            }

            TransferLineSet.prototype.add = function() {
                // add a group with x offset
                group = layer_group(this).append('g')
                           .attr('class', 'tl_set')
                           .attr('id', css_identifier('tl_set', this.type, this.layer, this.neuron, null))
                           .attr('transform', 'translate(' + this.x_offset() + ',0)')
                this.d3_group = group;
                // add a transfer line for every class in num_classes
                //if (this.type == 'xw' || this.type == 'hy' || this.type == 'hh') {
                    for (i = 0; i < num_classes; i++) {
                        tline = new TransferLine(this.type, this.layer, this.neuron, this, i)
                        tline.add()
                    }
                // } else if (this.type == 'wxh') {
                //     tline = new TransferLine(this.type, this.layer, this.neuron, this, 0)
                //     tline.add()
                // }
            }

            var tlines = [];
            var TransferLine = function(type, layer, neuron, set, index) {
                this.type = type;
                this.layer = layer;
                this.neuron = neuron;
                this.set = set;
                this.index = index;
                this.source = set.source;
                this.target = set.target;
                this.activated = false;
                this.was_activated = false;
                tlines.push(this)
            }

            var transfer_line_function = d3.svg.line().interpolate("basis");

            var transfer_line_data = function(transfer_line, state) {
                unit_offset = unit_height*transfer_line.index + unit_height/2

                source_y = transfer_line.source.y_position
                target_y = transfer_line.target.y_position

                target_y = transfer_line.type == 'wxh' ? target_y + unit_height/2 : target_y + unit_offset
                y_start = source_y + (transfer_line.type == 'hh' ? unit_height/2 : unit_offset)
                //  : The 105 is pixel-fixing
                full_transfer_width = (transfer_line.type == 'xw' || transfer_line.type == 'hy') ? (transfer_width + inner_margin) : 105;
                first_break = 1/4

                if (state == 'grow') {
                    line_data = [
                        [0, y_start],
                        [full_transfer_width*first_break, y_start],
                        [full_transfer_width*(1-first_break), target_y],
                        [full_transfer_width - 6, target_y]
                    ]                    
                } else if (state == 'init') {
                    line_data = [
                        [0, y_start],
                        [0, y_start],
                        [0, y_start],
                        [0, y_start]
                    ]                     
                }
                transfer_line.line_data = line_data
                return line_data
            }
            TransferLine.prototype.add = function() {
                // FIXME: Not DRY
                marker_id = css_identifier('marker', this.type, this.layer, this.neuron, this.index)
                marker = svg.append("defs").append("marker")
                    .attr("id", marker_id)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 2)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                  .append("path")
                    .attr("d", "M0,-5L10,0L0,5");
                this.marker = marker                       
                path = this.set.d3_group.append("path")
                        .attr("d", transfer_line_function(transfer_line_data(this, 'init')))
                        .attr('class', 'link')
                        .attr("stroke", medium_grey)
                        .attr('fill', 'none')
                        .attr('visibility', 'hidden')
                        .attr("marker-end", 'url(#' + marker_id + ')');
                this.path = path; 
            }

            TransferLine.prototype.grow = function(duration = default_sub_iter_duration) {
                this.path.attr('visibility', 'visible')
                  .transition().duration(duration)
                  .attr('d', transfer_line_function(transfer_line_data(this, 'grow')))
            }

            var add_label_pointer = function(d3_selection, text, position) {
                offset = 30
                client_rect = d3_selection[0][0].getBoundingClientRect()
                start_width = client_rect.width
                switch (position) {
                    case 'bottom left':
                        x_offset = -1.5*offset;
                        y_offset = offset + client_rect.height;
                        break;
                    case 'bottom':
                        x_offset = -unit_width/2
                        y_offset = offset*1.25 + client_rect.height;
                        break;
                    case 'top right':
                        x_offset = offset;
                        y_offset = -offset*1.25;
                        break;                        
                    case 'top':
                        x_offset = -unit_width/2;
                        y_offset = -offset*1.25;
                        break;
                    case 'top left':
                        x_offset = -1.75*offset;
                        y_offset = -offset;
                        break;                        
                    default: 
                        x_offset = offset
                        y_offset = -offset
                }

                label_pointer_group = d3_selection.append('g')
                                          .attr('class','label_pointer_group')
                                          .attr('transform', 'translate(' + x_offset + ',' + y_offset + ')')

                label_pointer_group.append('text').text(text)

                client_rect = d3_selection[0][0].getBoundingClientRect()
                new_width = client_rect.width
                width_diff = new_width-start_width

                marker_id = css_identifier('label_pointer', text.split(" ").join("_"))
                svg.append("defs").append("marker")
                    .attr('class', 'label_pointer_marker')
                    .attr("id", marker_id)
                    .attr("viewBox", "0 -5 10 10")
                    .attr("refX", 2)
                    .attr("refY", 0)
                    .attr("markerWidth", 6)
                    .attr("markerHeight", 6)
                    .attr("orient", "auto")
                  .append("path")
                    .attr("d", "M0,-5L10,0L0,5"); 
                // FIXME: pixel pushing
                line_y_offset = (position == 'bottom left') ? -14 : -5
                line_x_start = (position == 'bottom left') ? width_diff/2 : -4
                offset = (position == 'bottom left') ? -(offset + unit_width/2) : offset - 5
                if (position == 'bottom left') {
                    line_data = [
                        [line_x_start, line_y_offset], 
                        [line_x_start, offset],
                        [-x_offset-5, offset]
                    ]
                } else if (position == 'top left') {
                    line_data = [
                        [offset*1.75, line_y_offset], 
                        [-x_offset + 10, line_y_offset],
                        [-x_offset + 10, offset-5]
                    ]                    
                } else if (position == 'top right') {
                    line_data = [
                        [line_x_start, line_y_offset], 
                        [-x_offset + unit_width/2, line_y_offset],
                        [-x_offset + unit_width/2, offset]
                    ]
                } else if (position == 'bottom') {
                    line_data = [
                        [text.length*3, line_y_offset-5],
                        [text.length*3, -offset - 5]
                    ]
                } else if (position == 'top') {
                    line_data = [
                        [unit_width, 6],
                        [unit_width, offset+4]
                    ]
                }
                label_pointer_group.append('path')
                        .attr("d", transfer_line_function(line_data))
                        .attr('fill', 'none')
                        .attr('stroke', medium_grey)
                        .attr("marker-end", "url(#" + marker_id + ")"); 

            }

            add_network = function() {
                // add input units
                unitsets = [['input',0],['input',1],['output',0],['output',1],['target',0],['target',1]]
                for (i = 0; i < unitsets.length; i++) {
                   unitset = new UnitSet(unitsets[i][0], unitsets[i][1])
                   unitset.add()
                }

                for (layer_i = 0; layer_i < num_layers; layer_i++) {
                    for (neuron_i = 0; neuron_i < num_neurons; neuron_i++) {
                        neuron = new Neuron(layer_i, neuron_i);
                        neuron.add()

                        weight_types = ['xw', 'hy']
                        weight_types.forEach(function(type) {
                            weight_set = new WeightSet(type, layer_i, neuron_i);
                            weight_set.add()
                        })

                        hidden_state = new HiddenState(layer_i, neuron_i)
                        hidden_state.add()

                        transfer_line_types = ['xw', 'hh', 'hy', 'wxh']
                        transfer_line_types.forEach(function(type) {
                            tl_set = new TransferLineSet(type, layer_i, neuron_i)
                            tl_set.add()
                        });

                    }    
                }
            };

            add_network()


            // Song Stuff
            song_plot_group = svg.append("g")
                .attr("id", "song_plot_group")
                .attr("transform", "translate(0," + songs_bar_y_offset + ")")
            song_plot_yscale = d3.scale.linear().domain([0,num_classes]).range([0, song_plot_height])

            d3.range(0,num_classes).forEach(function(d) {
                song_plot_group.append("line")
                    .attr("x1", 0)
                    .attr("y1", song_plot_yscale(d))
                    .attr("x2", width)
                    .attr("y2", song_plot_yscale(d))
                    .attr("stroke", light_grey)
            })

            var songs = []
            var current_song = null

            var iter_note_sets = []
            var IterNoteSet = function(song, inputs, targets, iter_index) {
                this.song = song;
                this.inputs = inputs;
                this.targets = targets;
                this.iter_index = iter_index;
                iter_note_sets.push(this)
            }

            var Song = function(filename) {
                this.filename = filename;
                this.song_data = null;
                this.sequence_length = null;
                this.note_width = null;
                this.song_input_unit_path = null;
                this.song_target_unit_path = null;
                this.d3_notes = null;
                // function plot_song(song)
                var song = this
                d3.json(filename, function(data) {
                    song.raw_song_data = data;
                    song.song_data = []
                    data.forEach(function(notes, i) {
                        notes.forEach(function(note){
                            song.song_data.push({note: note, seq_idx: i})
                        })
                    })
                    song.sequence_length = data.length;
                    song.note_width = song_plot_width/song.sequence_length + 0.5 // width of each note plotted (e.g. 16th note)

                    // for every index in the total sequence, add an iter_note_set
                    data.forEach(function(notes, i) {
                        iter_note_set = new IterNoteSet(song, notes, data[i+1], i)
                    })                    
                })
            }

            //Song.prototype.xscale = d3.scale.linear().domain([0, this.sequence_length]).range([0, song_plot_width])

            Song.prototype.plot = function() {
                // scale from width of plot to seq length
                var xscale = d3.scale.linear().domain([0, this.sequence_length]).range([0, song_plot_width]);

                this.d3_notes = song_plot_group.selectAll('rect')
                                    .data(this.song_data).enter()
                                      .append('rect').attr('class', 'song_plot_unit')
                                      .attr('x', function(d,i) { return xscale(d.seq_idx) + song_plot_width + 2 })
                                      .attr('y', function(d) { return song_plot_yscale(d.note) })
                                      .attr('height', song_plot_note_height)
                                      .attr('width', this.note_width)
                                      .attr('fill', function(d) { return kolors(d.note) })                
            }

            Song.prototype.shift = function(iter_index, duration = default_sub_iter_duration) {
                var xscale = d3.scale.linear().domain([0, this.sequence_length]).range([0, song_plot_width]);
                this.d3_notes.transition().duration(duration)
                     .attr('x', function(d) { return xscale(d.seq_idx) + width/2 - xscale(iter_index) })
            }

            Song.prototype.draw_song_unit_line = function(type, state, duration = default_sub_iter_duration) {
                // draw lines from song to input or target
                note_offset = (type == 'input' ? 0 : this.note_width) + song_plot_width/2
                song_x = note_offset + this.note_width/2
                // FIXME: wacky conditional
                target_x = (layer1_visible ? 0 : layer_width/2) 
                    + (type == 'input' ? unit_width/2 : (layer_width - unit_width/2))
                    + ((type == 'target' && layer1_visible) ? layer_width : 0)
                song_y = height - song_plot_height
                target_y = unit_set_y_position + weight_set_height

                if (state == 'grow') {
                    line_data = [
                        [song_x, song_y],
                        [song_x, song_y - (song_y - target_y)/4],
                        [target_x, song_y - 3*(song_y - target_y)/4],
                        [target_x, target_y + 6] // plus 6 for the arrow
                    ]
                    if (type == 'input') {
                        this.song_unit_path.transition()
                            .duration(duration).attr('d', transfer_line_function(line_data))
                            .attr('class', 'flowline')                            
                    } else {
                        this.song_target_unit_path.transition()
                            .duration(duration).attr('d', transfer_line_function(line_data))
                            .attr('class', 'flowline')
                    }
                    
                } else if (state == 'init') {
                    marker_id = css_identifier('marker', type, null, null, null)
                    svg.append("defs").append("marker")
                        .attr("id", marker_id)
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 2)
                        .attr("refY", 0)
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .attr("orient", "auto")
                      .append("path")
                        .attr("d", "M0,-5L10,0L0,5");                    
                    line_data = [
                        [song_x, song_y],
                        [song_x, song_y],
                        [song_x, song_y],
                        [song_x, song_y]
                    ]
                    path = svg.append('path')
                        .attr("d", transfer_line_function(line_data))
                        .attr('class', 'link')
                        .attr("stroke", medium_grey)
                        .attr('fill', 'none')
                        .attr("marker-end", "url(#" + marker_id + ")"); 
                    if (type == 'input') {
                        this.song_unit_path = path
                    } else {
                        this.song_target_unit_path = path
                    }
                }                        
            }

            var ascender_height = 6,
                descender_height = 1
            Song.prototype.init_pointers = function() {
                pointers = ['t', 'between','tplus1']
                song = this
                pointers.forEach(function(pointer_type) {
                    var x1 = 1,
                        x2 = 1
                    if (pointer_type == 'between') {
                        x1 = song.note_width
                        x2 = song.note_width
                    } else if (pointer_type == 'tplus1') {
                        x1 = 2*song.note_width
                        x2 = 2*song.note_width
                    }
                    song_plot_group.append('line')
                      .attr('class', 'song_bar_pointer')
                      .attr('id', 'song_bar_' + pointer_type + '_pointer')
                      .attr('x1', x1 + song_plot_width/2)
                      .attr('y1', song_plot_height + descender_height)
                      .attr('x2', x2 + song_plot_width/2)
                      .attr('y2', -ascender_height)
                      .attr('stroke', medium_grey)
                })
                
                this.draw_song_unit_line('input', 'init')  
                this.draw_song_unit_line('target', 'init')

                song_plot_group.append('rect')
                    .attr('x',0)
                    .attr('y', -ascender_height)
                    .attr('width', song_plot_width/2)
                    .attr('height', song_plot_height + ascender_height)
                    .attr('fill', light_grey)
                    .attr('opacity', 0.5)
            }
            var song = new Song('daft_punk-one_more_time.json')

            // initial state stuff
            if (!layer1_visible) {
                d3.select('#layer1').selectAll('*').style('visibility', 'hidden')
                d3.select('#layer0').attr('transform', 'translate(' + layer_width/2 + ',0)')
            }

            var current_iter = 0
            var current_iter_notes = []

            var color_units = function(type, layer) {
                these_notes = (type == 'input') ? current_iter_notes.inputs : current_iter_notes.targets
                _.where(unit_sets, {type: type, layer: layer}).forEach(function(unit_set) {
                    unit_set.d3_group.selectAll('.unit')
                      .transition()
                      .duration(playing ? 0 : default_sub_iter_duration)
                      .delay(playing ? 0 : default_sub_iter_duration)
                      .style('fill', function(d, i) { return _.contains(these_notes, i) ? kolors(i) : 'white'})
                })       
            }

            var sub_iter0 = function() {
                song.shift(current_iter)
                color_units('input', 0)
                color_units('target', layer1_visible ? 1 : 0)
            }

            // FIXME: Not dry with sub_iter2
            var sub_iter1 = function(layer = 0) {
                xw_lines = _.where(tlines, {type: 'xw', layer: layer})
                output_units_layer0 = _.where(unit_sets, {layer: 0, type: 'output'})[0]

                xw_lines.forEach(function(tl) {
                    tl.activated = _.contains(current_iter_notes.inputs, tl.index) || (layer == 1)
                    // turn on flowlines not already active
                    if (tl.activated && !tl.was_activated) {
                        tl.path.transition()
                            .duration(default_sub_iter_duration)
                            // has to grow first
                            .delay(playing ? 0 : default_sub_iter_duration)
                            .attr('stroke', kolors(tl.index))
                            .attr('stroke-opacity', (layer == 1) ? Math.max(0.15, output_units_layer0.values[tl.index]) : 1)
                            .attr('class', 'flowline')
                        tl.marker
                            .transition().duration(playing ? 0 : default_sub_iter_duration)
                            .delay(playing ? 0 : default_sub_iter_duration)
                            .style('fill', kolors(tl.index))
                            .style('fill-opacity', (layer == 1) ? Math.max(0.15, output_units_layer0.values[tl.index]) : 1)
                    } else if (tl.was_activated && !tl.activated) {
                        // turn off flowlines no longer active
                        tl.path.transition()
                            .duration(default_sub_iter_duration)
                            .delay(playing ? 0 : default_sub_iter_duration)
                            .attr('class', 'link')
                        tl.marker.transition()
                            .duration(playing ? 0 : default_sub_iter_duration)
                            .delay(playing ? 0 : default_sub_iter_duration)
                            .style('fill', light_grey)                        
                    }
                    tl.was_activated = tl.activated
                })        
            }

            var sub_iter2 = function(layer = 0) {
                wxh_lines = _.where(tlines, {type: 'wxh', layer: layer})
                wxh_lines.forEach(function(tl) {                 
                    tl.activated = _.contains(current_iter_notes.inputs, tl.index) || (layer == 1)
                    // turn on flowlines not already active
                    if (tl.activated && !tl.was_activated) {
                        tl.path.transition()
                          .duration(playing ? 0 : default_sub_iter_duration)
                          // has to grow first
                          .delay(playing ? 0 : default_sub_iter_duration)
                          .attr('class', 'flowline')
                          .attr('stroke', kolors(tl.index))
                          .attr('opacity', Math.max(0.5, Math.abs(tl.source.weights[tl.index])))
                        tl.marker.transition()
                          .duration(playing ? 0 : default_sub_iter_duration)
                          .delay(playing ? 0 : default_sub_iter_duration)
                          .style('fill', kolors(tl.index))
                          .attr('opacity', Math.max(0.5, Math.abs(tl.source.weights[tl.index])))
                    } else if (tl.was_activated && !tl.activated) {
                        // turn off flowlines no longer active
                        tl.path.attr('class', 'link')
                        tl.marker.style('fill', light_grey)
                    }
                    tl.was_activated = tl.activated
                })
                _.where(hidden_states, {layer: layer}).forEach(function(hs) {
                    hs.update(playing ? 0 : default_sub_iter_duration)
                })
            }

            //updating of the lines is done in hs.update()            
            var sub_iter3 = function() {}

            var sub_iter4 = function(layer = 0) {
                hy_lines = _.where(tlines, {type: 'hy', layer: layer})
                hy_lines.forEach(function(tl) {
                    weight = tl.source.weights[tl.index]
                    hidden_state = _.find(hidden_states, {layer: tl.layer, neuron: tl.neuron})
                    prob = weight*hidden_state.value
                    tl.value = prob
                    tl.path.transition()
                        .duration(playing ? 0 : default_sub_iter_duration)
                        .delay(playing ? 0 : default_sub_iter_duration)
                        .attr('class', 'flowline')
                    tl.path.attr('stroke', wkolors(prob))
                    tl.marker.style('fill', wkolors(prob))
                })
                if (layer == 0) { update_output_units(0, type) }
            }

            // FIXME
            var update_output_units = function(layer) {
                components = (layer == 0) ? {type: 'output', layer:0} : {type: 'input', layer:1}
                // FIXME: Where is kind of silly, should be just find, simple to fix
                output_unit_sets = _.where(unit_sets, components)

                output_unit_sets.forEach(function(us) {
                    lines = _.where(tlines, {layer: 0, type: 'hy'})
                    
                    us.d3_group.selectAll('.unit')
                      .style('fill', function(d, i) { return kolors(i)})
                      .attr('fill-opacity', function(d, i) {
                            this_probs = _.map(_.where(lines, {index: i}), function(l) { return l.value })
                            total_prob = _.reduce(this_probs, function(memo, num) { return memo + num })
                            us.values[i] = total_prob
                            return Math.max(0.15, total_prob)
                      })
                })                
            }

            var iter = function() {
                current_iter += 1
                current_iter_notes = iter_note_sets[current_iter]
                sub_iter0()
                sub_iter1()
                sub_iter2()
                sub_iter3()
                sub_iter4()
            }

            var current_state = 'entered'
            var playing = false
            var two_layers_setup = false
            $('#action-button').on('click', function() {
                current_iter_notes = iter_note_sets[current_iter]

                if (current_state == 'entered') {
                    $('#info-text').html("The first step is to gather the training data and initialize random weights. Now we're ready to start training!")
                    $('#action-button').html("First step: Input song")

                    song.plot()

                    weight_sets.forEach(function(set) {
                        set.update_weights();
                    })

                    add_label_pointer(_.find(weight_sets, {layer: 0, type: 'xw', neuron: 0}).d3_group, 'input weights', 'top right')
                    add_label_pointer(_.find(weight_sets, {layer: 1, type: 'xw', neuron: 0}).d3_group, 'input weights', 'top right')

                    current_state = 'network_setup'
                } else if (current_state == 'network_setup') {
                    $('#info-text').html("In the first iteration, the <b>input</b> is the first note and the <b>target</b> is the second note.")
                    $('#action-button').html("Next Step")
                    song.init_pointers()

                    song.draw_song_unit_line('input', 'grow')
                    song.draw_song_unit_line('target', 'grow')

                    add_label_pointer(
                        _.find(unit_sets, {layer: 0, type: 'input'}).d3_group, 'inputs', 'top right')
                    add_label_pointer(
                        _.find(unit_sets, {layer: (layer1_visible ? 1 : 0), type: 'target'}).d3_group, 'targets', 'top left')

                    sub_iter0()
 
                    current_state = 'sub_iter0'
                } else if (current_state == 'sub_iter0') {
                    $('#info-text').html("The input is multiplied by a set of weights.")
                    xw_lines = _.where(tlines, {type: 'xw', layer: 0})
                    xw_lines.forEach(function(tl) { return tl.grow() })                    
                    sub_iter1()
                    current_state = 'sub_iter1'
                } else if (current_state == 'sub_iter1') {
                    $('#info-text').html("The weighted sum is then passed to the \"memory\" cell. This is the <b>magic of a recurrent neural network.</b>")
                    wxh_lines = _.where(tlines, {type: 'wxh', layer: 0})
                    wxh_lines.forEach(function(tl) {
                        memory_cells_open_close('left', 0)
                        tl.grow()
                    })
                    add_label_pointer(_.find(memory_cells, {layer: 0}).d3_group, 'memory', 'top right')
                    sub_iter2()
                    current_state = 'sub_iter2'
                } else if (current_state == 'sub_iter2') {
                    $('#info-text').html("The memory cell stores the information in the <b>hidden state</b> which can be recalled on the next iteration.")
                    hh_lines = _.where(tlines, {type: 'hh', layer: 0})
                    hh_lines.forEach(function(tl) {
                        memory_cells_open_close('right', 0)
                        tl.grow()
                        // only needs to happen once
                        tl.path.transition().duration(default_sub_iter_duration)
                          .delay(default_sub_iter_duration)
                          .attr('class', 'flowline')
                    })
                    add_label_pointer(_.find(weight_sets, {layer: 0, neuron: 0, type: 'hy'}).d3_group, 'output weights', 'top right')
                    sub_iter3()
                    current_state = 'sub_iter3'
                } else if (current_state == 'sub_iter3') {
                    $('#info-text').html("Finally, the hidden state is multiplied by an output set of weights, which formulates the probability of each note following the current note.")

                    hy_lines = _.where(tlines, {type: 'hy', layer: 0})
                    hy_lines.forEach(function(tl) {
                        tl.grow()
                    })
                    add_label_pointer(_.find(unit_sets, {type: 'output', layer: 0}).d3_group, 'outputs', 'top')
                    sub_iter4()
                    current_state = 'sub_iter4'
                // branching: either we are done setting up the first layer and there's nothing else to do
                // or we need to setup the second layer                   
                } else if (current_state == 'sub_iter4' && (!layer1_visible || two_layers_setup)) {
                    $('#info-text').html("We calculate how wrong our guess was and update the weights. (ADD ME: VISUALIZE")
                    $('#action-button').html("Update weights")

                    current_state = 'backpropagate'
                } else if (current_state == 'sub_iter4' && layer1_visible && !two_layers_setup) {
                    $('#info-text').html("The output of the first layer comes the input to the second layer.")
                    update_output_units(1)
                    $('#action-button').html("Next Layer")
                    current_state = 'next layer'
                } else if (current_state == 'next layer') {
                    $('#info-text').html("The second layer works just like the first.")

                    xw_lines = _.where(tlines, {type: 'xw', layer: 1})
                    xw_lines.forEach(function(tl) { return tl.grow() })                    
                    sub_iter1(1)

                    wxh_lines = _.where(tlines, {type: 'wxh', layer: 1})
                    wxh_lines.forEach(function(tl) {
                        memory_cells_open_close('left', 1)
                        tl.grow()
                    })
                    sub_iter2(1)

                    hh_lines = _.where(tlines, {type: 'hh', layer: 1})
                    hh_lines.forEach(function(tl) {
                        memory_cells_open_close('right', 1)
                        tl.grow()
                        // only needs to happen once
                        tl.path.transition().duration(default_sub_iter_duration)
                          .delay(default_sub_iter_duration)
                          .attr('class', 'flowline')
                    })
                    // nothing to be done here
                    sub_iter3()

                    hy_lines = _.where(tlines, {type: 'hy', layer: 1})
                    hy_lines.forEach(function(tl) {
                        tl.grow()
                    })
                    sub_iter4(1)

                    two_layers_setup = true
                    current_state = 'sub_iter4'
                } else if (current_state == 'backpropagate') {
                    $('#info-text').html("Now that we see how the network is working, let's train on the full song!")
                    $('#action-button').html("Train all")

                    // reverse lines
                    tlines.forEach(function(line, i) {
                        reversed_line_data = line.line_data.reverse()
                        reversed_line_data = _.map(reversed_line_data, function(ld) { return [ld[0]+5, ld[1]] })
                        line.path.transition().duration(default_sub_iter_duration)
                            .attr('d', transfer_line_function(reversed_line_data))
                    })               
                    current_state = 'train all'
                } else if (current_state == 'train all') {
                    // re-reverse lines
                    playing = true
                    tlines.forEach(function(line, i) {
                        line.path.transition().duration(default_sub_iter_duration)
                            .attr('d', transfer_line_function(line.line_data.reverse()))
                    })
                    for (i = 1; i < song.sequence_length-1; i++) {
                        // nothing is done in sub_iter 3 so though we have 5 sub iterations we only care about 4 of them
                        setTimeout(function(){ iter(); }, default_sub_iter_duration + i*default_sub_iter_duration);
                    }
                }
            })
            
        </script>
    </footer>
</html>
