<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}

svg {
  display: block;
  margin: 0px auto;
}

.negative_region {
    opacity: 0.3;
}

.pos_bar {
    fill: #fefefe;
    stroke: #333;
}

.neg_bar {
    fill: #333;
    stroke: #fefefe;
}

.wx_bar {
    opacity: 0;
}

.link, .addition_link {
  fill: none;
  stroke: #000;
  opacity: .1;
}

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>

    // layout
    var golden_ratio = 1.618,
        width = 1024,
        total_height = 768, // height of whole container
        height1 = total_height/golden_ratio,
        height2 = height1/golden_ratio;

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", total_height)
      .append("g")

    // TRANSFER FUNCTION
    var transfer_multiply_height = height2
    var transfer_addition_height = transfer_multiply_height*2

    // scales for transfer function
    var transfer_multiply_xscale = d3.scale.linear()
        .range([0, transfer_multiply_height]);
    var transfer_multiply_yscale = d3.scale.linear()
        .domain([-6,0,6])
        .range([-transfer_multiply_height/2, 0, transfer_multiply_height/2]);

    // scales for transfer function
    var transfer_addition_xscale = d3.scale.linear()
        .range([0, transfer_addition_height]);
    var transfer_addition_yscale = d3.scale.linear()
        .domain([-6,0,6])
        .range([-transfer_addition_height/2, 0, transfer_addition_height/2]);


    // wtoffset for weights
    var wtoffset = transfer_multiply_height/2
    var barwidth = 10
    var offset = 2
    var bandWidth = 140
    var unit_bar_height = transfer_multiply_yscale(1)

    // group for first variable
    var transfer_multiply_group_1 = svg.append('svg:g')
        .attr('id', 'transfer_group_1')
        .attr('class', 'transfer_group_multiply')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height)

    transfer_multiply_group_1.append('svg:rect')
        .attr('class', 'negative_region')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height/2)
        .attr('y', transfer_multiply_height/2)
        .attr('fill', '#333')

    var transfer_multiply_group_2 = svg.append('svg:g')
        .attr('id', 'transfer_group_2')
        .attr('class', 'transfer_group_multiply')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height)
        .attr('transform', "translate(0," + transfer_multiply_height + ")")

    transfer_multiply_group_2.append('svg:rect')
        .attr('class', 'negative_region')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height/2)
        .attr('y', transfer_multiply_height/2)
        .attr('fill', '#333')

    // The addition square
    var transfer_addition_group = svg.append('svg:g')
        .attr('id', 'transfer_addition_group')
        .attr('width', transfer_addition_height)
        .attr('height', transfer_addition_height)
        .attr('transform', "translate(" + transfer_addition_height/2 + ",0)")

    transfer_addition_group.append('svg:rect')
        .attr('class', 'negative_region')
        .attr('width', transfer_addition_height)
        .attr('height', transfer_addition_height/2)
        .attr('y', transfer_addition_height/2)
        .attr('fill', '#333') 

    var create_interval_data = function(x, type, weight) {
        // create unit and modulo of data
        // FIXME: not sure why this conditional is necessary
        var x_data = d3.range((type == 'wx' || type == 'w' || type == 'wx_start') ? 1 : 0, Math.abs(Math.round(x))).map(function() {
            return (x < 0) ? -1 : 1
        })
        x_data.push(x%1)
        x_data = x_data.map(function(interval, idx) {
            return {original: x, type: type, value: interval, index: idx, weight: weight}
        })
        return x_data   
    }
           
    var yposition = function(d) {
        if (d.value < 0) {
            if (!(d.type == 'wx' || d.type == 'wx_start')) {
                ypos = transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index)
                return ypos
            } else {
                ypos = transfer_multiply_height/2
                return ypos
            }
        } else {
            if (!(d.type == 'wx' || d.type == 'wx_start')) {
                ypos = transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index)
                return ypos
            } else {
                ypos = transfer_multiply_height/2 - transfer_multiply_yscale(d.value)
                return ypos
            } 
        }
    }

    var yposition_addition = function(d) {
        if (d.value < 0) {
            ypos = transfer_multiply_yscale(d.index) + 2*(d.index)
            return ypos
        } else {
            ypos = transfer_addition_height/2 - transfer_multiply_yscale(d.index) - transfer_multiply_yscale(d.value) - 2*(d.index)
            return ypos
        }
    }

    var barheight = function(d) {
      return Math.abs(transfer_multiply_yscale(d.value))
    }

    var add_links = function(node_data, group, update) {
        var lineFunction = d3.svg.line().interpolate("basis");

        var lineData = function(d, update) {
          var y_pos = yposition(d) + barheight(d)/2
          var x_update = wtoffset+barwidth
          var y_update = y_pos
          if (update) {
            if (d.weight * d.value < 0) {
                y_update = transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index) + barheight(d)/2
            } else if (d.weight < 0 && d.value < 0) {
                y_update = transfer_multiply_height/2 - transfer_multiply_yscale(d.index) - 2*(d.index) - transfer_multiply_yscale(Math.abs(d.value)) + barheight(d)/2
            }
          }
          return [ 
            [ barwidth, y_pos],
            [ update ? x_update - 3*x_update/4 : barwidth, y_pos],
            [ update ? x_update - x_update/4 : barwidth, update ? y_update : y_pos],
            [ update ? x_update-barwidth : barwidth,  update ? y_update : y_pos]]
        }

        if (!update) {
          group.selectAll('path.link').data(node_data)
            .enter().append("path")
            .attr("d", function(d) { return lineFunction(lineData(d)) })
            .attr('class', 'link')
            .attr("stroke", "white")
            .attr("stroke-width", function(d) { return barheight(d) })
            .attr("fill", "black");                    

        } else {
            group.selectAll('.link').transition().delay(100).duration(2000)
               .attr('d', function(d) { return lineFunction(lineData(d, true)) })
        }
    }

    var add_addition_links = function(node_data, group, update) {
        var lineFunction = d3.svg.line().interpolate("basis");

        var lineData = function(d, update) {
          var x_start = wtoffset+barwidth*2
          if (d.value < 0) {
              y_pos = transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index) + barheight(d)/2
          } else {
              y_pos = transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index) + barheight(d)/2
          }
          var x_update = transfer_multiply_height/2-barwidth*2
          var y_update = y_pos
          if (update) {
            y_update = yposition_addition(d)+barheight(d)/2
          }
          return [
            [ x_start, y_pos],
            [ update ? x_start + x_update/4 : x_start, y_pos],
            [ update ? x_start + 3*x_update/4 : x_start, update ? y_update : y_pos],
            [ update ? x_start + x_update : x_start,  update ? y_update : y_pos]]
        }

        if (!update) {
          group.selectAll('path.addition_link').data(node_data)
            .enter().append("path")
            .attr("d", function(d) { return lineFunction(lineData(d)) })
            .attr('class', 'addition_link')
            .attr("stroke", "white")
            .attr("stroke-width", function(d) { return barheight(d) })
            .attr("fill", "black");                    

        } else {
            group.selectAll('.addition_link').transition().delay(4000).duration(2000)
               .attr('d', function(d) { return lineFunction(lineData(d, true)) })
        }
    }

    // function to add x and w to transfer multiply group plot
    var addwx_multiply = function(x, w, group, group_indx) {
        // create unit and modulo of data
        x_data = create_interval_data(x, 'x', w)
        x_start_data = create_interval_data(x, 'x_start', w)
        w_data = create_interval_data(w, 'w', w)
        wx_start_data = create_interval_data(x*w, 'wx_start', w)
        wx_data = create_interval_data(x*w, 'wx', w)

        x_data = x_data.concat(w_data).concat(wx_data).concat(x_start_data).concat(wx_start_data)
        add_links(x_start_data, group)
        add_links(x_start_data, group, true)
        add_addition_links(wx_start_data, group)
        add_addition_links(wx_start_data, group, true)

        var bars = group.selectAll('multiply_bar')
          .data(x_data)
          .enter().append('svg:rect')
          .attr('class', function(d) {
            return ((d.value > 0) ? 'pos_bar ' : 'neg_bar ') + d.type + '_bar multiply_bar ' + 'group' + group_indx + '_bar'
          })
          .attr('x', function(d) {
              if (d.type == 'x' || d.type =='x_start') {
                  return 0
              } else if (d.type == 'wx' || d.type == 'wx_start') {
                  return wtoffset+barwidth
              } else if (d.type == 'w') {
                  return wtoffset;
              }
          })
          .attr('y', function(d) { return yposition(d) })
          .attr('width', barwidth)
          .attr('opacity', function(d) { return (d.type == 'wx_start' ? 0 : 1) })
          .attr('height', function(d) {
            return Math.abs(transfer_multiply_yscale(d.value))
          })
    }
    addwx_multiply(-2.2, -1.8, transfer_multiply_group_1, 1)
    addwx_multiply(2.2, -0.8, transfer_multiply_group_2, 2)

    var stack_bars = function(class_selection) {
        d3.selectAll(class_selection).each(function(d, i) {
            d3.select(this).transition()
              .delay(2100 + 300*i)
              .duration(300)
              .style('opacity', 1)
              .attr('y', function(d) {
                if (d.value < 0) {
                    return transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index)
                } else {
                    return transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index)             
                }
              })

        })        
    }
    // step function for transitioning and multiplying bars
    var multiply = function(group_indx) {
        // select all x_bars, move and disappear them
        d3.selectAll('.x_bar.multiply_bar').transition()
          .delay(100)
          .duration(2000)
          .attr('x', wtoffset)
          .attr('y', function(d) {
            if (d.weight*d.value < 0) {
                return transfer_multiply_height/2 +transfer_multiply_yscale(d.index) + 2*(d.index)
            } else if (d.weight < 0 && d.value < 0) {
                return transfer_multiply_height/2 - transfer_multiply_yscale(d.index) - 2*(d.index) - transfer_multiply_yscale(Math.abs(d.value))
            } else {
                return transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index)
            }
          })
          .attr('height', function(d) {
            return Math.abs(transfer_multiply_yscale(d.value))
          })
          .transition().duration(500).style('opacity',0.2)

        // FIXME: would like this to be a transition but d3 doesn't like to transition classes
        d3.selectAll('.x_bar.multiply_bar')
          .classed("neg_bar", function(d) { return d.value*d.weight < 0 ? true : false})
          .classed("pos_bar", function(d) { return d.value*d.weight > 0 ? true : false})

        // fade x_start and w
        d3.selectAll('.x_start_bar').transition().delay(100).duration(2000).style('opacity', 0.2)
        d3.selectAll('.w_bar').transition().delay(100).duration(2000).style('opacity', 0.2)

        // stack wx bars
        var wx_selection = '.wx_bar.multiply_bar.group' + group_indx + '_bar'
        var wx_start_selection = ' .wx_start_bar.multiply_bar.group' + group_indx + '_bar'
        stack_bars(wx_selection)
        stack_bars(wx_start_selection)
    }
    multiply(1)
    multiply(2)

    // function to transition wx bars to the transfer addition space
    var add = function(group_indx) {
        d3.selectAll('.wx_start_bar').transition().delay(4000).duration(1000).style('opacity', 0.2)
        d3.selectAll('.wx_bar.multiply_bar.group' + group_indx + '_bar').transition().delay(4000).duration(2000)
          .attr('x', transfer_multiply_height)
          .attr('y', function(d) { return yposition_addition(d) })
    }
    add(1)
    add(2)
</script>

