<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}

svg {
  display: block;
  margin: 0px auto;
}

.negative_region {
    opacity: 0.3;
}

.pos_bar {
    fill: #fefefe;
    stroke: #333;
}

.neg_bar {
    fill: #333;
    stroke: #fefefe;
}

.wx_bar {
    opacity: 0;
}

.link, .addition_link {
  fill: none;
  stroke: #000;
  opacity: .1;
}

</style>
<body>
<script src="//d3js.org/d3.v3.min.js"></script>
<script>

    // layout
    var golden_ratio = 1.618,
        width = 1024,
        total_height = 768, // height of whole container
        height1 = total_height/golden_ratio,
        height2 = height1/golden_ratio;

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", total_height)
      .append("g")

    // TRANSFER FUNCTION
    var transfer_multiply_height = height2
    var transfer_addition_height = transfer_multiply_height*2

    // scales for transfer function
    var transfer_multiply_xscale = d3.scale.linear()
        .range([0, transfer_multiply_height]);
    var transfer_multiply_yscale = d3.scale.linear()
        .domain([-6,0,6])
        .range([-transfer_multiply_height/2, 0, transfer_multiply_height/2]);

    // scales for transfer function
    var transfer_addition_xscale = d3.scale.linear()
        .range([0, transfer_addition_height]);
    var transfer_addition_yscale = d3.scale.linear()
        .domain([-6,0,6])
        .range([-transfer_addition_height/2, 0, transfer_addition_height/2]);

    // wtoffset for weights
    var wtoffset = transfer_multiply_height/2
    var barwidth = 10
    var offset = 2
    var bandWidth = 140
    var unit_bar_height = transfer_multiply_yscale(1)

    // group for first variable
    var transfer_multiply_group_1 = svg.append('svg:g')
        .attr('id', 'transfer_group_1')
        .attr('class', 'transfer_group_multiply')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height)

    transfer_multiply_group_1.append('svg:rect')
        .attr('class', 'negative_region')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height/2)
        .attr('y', transfer_multiply_height/2)
        .attr('fill', '#333')

    var transfer_multiply_group_2 = svg.append('svg:g')
        .attr('id', 'transfer_group_2')
        .attr('class', 'transfer_group_multiply')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height)
        .attr('transform', "translate(0," + transfer_multiply_height + ")")

    transfer_multiply_group_2.append('svg:rect')
        .attr('class', 'negative_region')
        .attr('width', transfer_multiply_height)
        .attr('height', transfer_multiply_height/2)
        .attr('y', transfer_multiply_height/2)
        .attr('fill', '#333')

    // The addition square
    var transfer_addition_group = svg.append('svg:g')
        .attr('id', 'transfer_addition_group')
        .attr('width', transfer_addition_height)
        .attr('height', transfer_addition_height)
        .attr('transform', "translate(" + transfer_addition_height/2 + ",0)")

    transfer_addition_group.append('svg:rect')
        .attr('class', 'negative_region')
        .attr('width', transfer_addition_height)
        .attr('height', transfer_addition_height/2)
        .attr('y', transfer_addition_height/2)
        .attr('fill', '#333') 

    var create_interval_data = function(x, type, weight) {
        // create unit and modulo of data
        // FIXME: not sure why this conditional is necessary
        var x_data = d3.range((type == 'wx' || type == 'w' || type == 'wx_start') ? 1 : 0, Math.abs(Math.round(x))).map(function() {
            return (x < 0) ? -1 : 1
        })
        x_data.push(x%1)
        x_data = x_data.map(function(interval, idx) {
            return {original: x, type: type, value: interval, index: idx, weight: weight}
        })
        return x_data   
    }
           
    var yposition = function(d) {
        if (d.value < 0) {
            if (!(d.type == 'wx' || d.type == 'wx_start')) {
                ypos = transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index)
                return ypos
            } else {
                ypos = transfer_multiply_height/2
                return ypos
            }
        } else {
            if (!(d.type == 'wx' || d.type == 'wx_start')) {
                ypos = transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index)
                return ypos
            } else {
                ypos = transfer_multiply_height/2 - transfer_multiply_yscale(d.value)
                return ypos
            } 
        }
    }

    var yposition_addition = function(d, group_indx) {
        if (d.value < 0) {
            ypos = transfer_multiply_yscale(d.index) + 2*(d.index)
            if (group_indx == 1) {
                ypos += transfer_multiply_height
            }
            return ypos
        } else {
            ypos = transfer_addition_height/2 - transfer_multiply_yscale(d.index) - transfer_multiply_yscale(d.value) - 2*(d.index)
            if (group_indx == 2) {
                ypos -= transfer_multiply_height
            }
            return ypos
        }
    }

    var barheight = function(d) {
      return Math.abs(transfer_multiply_yscale(d.value))
    }

    var total_step_time = 5000
    var sub_step_time = total_step_time/6

    var draw_multiply_links = function(node_data, group, update) {
        var lineFunction = d3.svg.line().interpolate("basis");

        var lineData = function(d, update) {
          var y_pos = yposition(d) + barheight(d)/2
          var x_update = wtoffset+barwidth
          var y_update = y_pos
          if (update) {
            if (d.weight * d.value < 0) {
                y_update = transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index) + barheight(d)/2
            } else if (d.weight < 0 && d.value < 0) {
                y_update = transfer_multiply_height/2 - transfer_multiply_yscale(d.index) - 2*(d.index) - transfer_multiply_yscale(Math.abs(d.value)) + barheight(d)/2
            }
          }
          return [ 
            [ barwidth, y_pos],
            [ update ? x_update - 3*x_update/4 : barwidth, y_pos],
            [ update ? x_update - x_update/4 : barwidth, update ? y_update : y_pos],
            [ update ? x_update-barwidth : barwidth,  update ? y_update : y_pos]]
        }

        if (!update) {
          d3.select(group).selectAll('path.link').data(node_data)
            .enter().append("path")
            .attr("d", function(d) { return lineFunction(lineData(d)) })
            .attr('class', 'link')
            .attr("stroke", "white")
            .attr("stroke-width", function(d) { return barheight(d) })
            .attr("fill", "black");                    

        } else {
            d3.select(group).selectAll('.link').transition().duration(sub_step_time)
               .attr('d', function(d) { return lineFunction(lineData(d, true)) })
        }
    }

    var draw_addition_links = function(node_data, group, group_indx, update, shift) {
        var lineFunction = d3.svg.line().interpolate("basis");

        var lineData = function(d, update, shift) {
          var shift_scaled = transfer_multiply_yscale(shift)
          var x_start = wtoffset+barwidth*2
          if (d.value < 0) {
              y_pos = transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index) + barheight(d)/2
          } else {
              y_pos = transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index) + barheight(d)/2
          }
          var x_update = transfer_multiply_height/2-barwidth*2
          var y_update = y_pos
          if (update == 'first') {
            y_update = yposition_addition(d, group_indx) + barheight(d)/2
          } else if (update == 'second') {
            padding_shift = (shift < 0) ? Math.ceil(Math.abs(shift)) : Math.ceil(shift)
            y_update = yposition_addition(d, group_indx) + barheight(d)/2 - shift_scaled - 2*Math.ceil(shift) + padding_shift
          }
          update_pos = (update != undefined) ? true : false
          return [
            [ x_start, y_pos],
            [ update_pos ? x_start + x_update/4 : x_start, y_pos],
            [ update_pos ? x_start + 3*x_update/4 : x_start, update_pos ? y_update : y_pos],
            [ update_pos ? x_start + x_update : x_start,  update_pos ? y_update : y_pos]]
        }

        if (update == undefined) {
          d3.select(group).selectAll('path.addition_link').data(node_data)
            .enter().append("path")
            .attr("d", function(d) { return lineFunction(lineData(d)) })
            .attr('class', 'addition_link group' + group_indx)
            .attr("stroke", "white")
            .attr("stroke-width", function(d) { return barheight(d) })
            .attr("fill", "black");                    
        } else if (update == 'first') {
            d3.select(group).selectAll('.addition_link').transition().delay(sub_step_time*2).duration(sub_step_time)
               .attr('d', function(d) { return lineFunction(lineData(d, 'first')) })
        } else if (update == 'second') {
            d3.select(group).selectAll('.addition_link.group1').transition().delay(sub_step_time*3).duration(sub_step_time)
               .attr('d', function(d) { return lineFunction(lineData(d, 'second', shift)) })
        }
    }

    // function to add x and w to transfer multiply group plot
    var addwx_multiply = function(data, group, group_indx) {
        var bars = group.selectAll('multiply_bar')
          .data(data)
          .enter().append('svg:rect')
          .attr('class', function(d) {
            return ((d.value > 0) ? 'pos_bar ' : 'neg_bar ') + d.type + '_bar multiply_bar ' + 'group' + group_indx + '_bar'
          })
          .attr('x', function(d) {
              if (d.type == 'x' || d.type =='x_start') {
                  return 0
              } else if (d.type == 'wx' || d.type == 'wx_start') {
                  return wtoffset+barwidth
              } else if (d.type == 'w') {
                  return wtoffset;
              }
          })
          .attr('y', function(d) { return yposition(d) })
          .attr('width', barwidth)
          .attr('opacity', function(d) { return (d.type == 'wx_start' ? 0 : 1) })
          .attr('height', function(d) {
            return Math.abs(transfer_multiply_yscale(d.value))
          })
    }

    var stack_bars = function(class_selection) {
        var all_bars = d3.selectAll(class_selection)
        num_bars = all_bars[0].length
        all_bars.each(function(d, i) {
            d3.select(this).transition()
              .delay(sub_step_time)
              .duration(sub_step_time)
              .style('opacity', 1)
              .attr('y', function(d) {
                if (d.value < 0) {
                    return transfer_multiply_height/2 + transfer_multiply_yscale(d.index) + 2*(d.index)
                } else {
                    return transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index)             
                }
              })

        })        
    }
    // step function for transitioning and multiplying bars
    var multiply = function(group_indx) {
        // select all x_bars, move and disappear them
        d3.selectAll('.x_bar.multiply_bar').transition()
          .duration(sub_step_time)
          .attr('x', wtoffset)
          .attr('y', function(d) {
            if (d.weight*d.value < 0) {
                return transfer_multiply_height/2 +transfer_multiply_yscale(d.index) + 2*(d.index)
            } else if (d.weight < 0 && d.value < 0) {
                return transfer_multiply_height/2 - transfer_multiply_yscale(d.index) - 2*(d.index) - transfer_multiply_yscale(Math.abs(d.value))
            } else {
                return transfer_multiply_height/2 - transfer_multiply_yscale(d.value) - transfer_multiply_yscale(d.index) - 2*(d.index)
            }
          })
          .attr('height', function(d) {
            return Math.abs(transfer_multiply_yscale(d.value))
          })
          .transition().duration(500).style('opacity',0.2)

        // FIXME: would like this to be a transition but d3 doesn't like to transition classes
        d3.selectAll('.x_bar.multiply_bar')
          .classed("neg_bar", function(d) { return d.value*d.weight < 0 ? true : false})
          .classed("pos_bar", function(d) { return d.value*d.weight > 0 ? true : false})

        // fade x_start and w
        d3.selectAll('.x_start_bar').transition().duration(sub_step_time).style('opacity', 0.2)
        d3.selectAll('.w_bar').transition().duration(sub_step_time).style('opacity', 0.2)

        // stack wx bars
        var wx_selection = '.wx_bar.multiply_bar.group' + group_indx + '_bar'
        var wx_start_selection = ' .wx_start_bar.multiply_bar.group' + group_indx + '_bar'
        stack_bars(wx_selection)
        stack_bars(wx_start_selection)
    }

    // function to transition wx bars to the transfer addition space
    var move_to_addition = function(group_indx) {
        d3.selectAll('.wx_start_bar').transition().delay(sub_step_time*2).duration(sub_step_time).style('opacity', 0.2)
        d3.selectAll('.wx_bar.multiply_bar.group' + group_indx + '_bar').transition().delay(sub_step_time*2).duration(sub_step_time)
          .attr('x', transfer_multiply_height)
          .attr('y', function(d) { return yposition_addition(d, group_indx) })
    }

    var add = function(shift, shift_sign) {
        // select all the bars in the first group and shift them up or down depending on the value of the second group
        var shift_scaled = transfer_multiply_yscale(shift)
        d3.selectAll('.wx_bar.group1_bar').transition().delay(sub_step_time*3).duration(sub_step_time)
            .attr('y', function(d) {
                padding_shift = (shift < 0) ? 2*Math.ceil(Math.abs(shift)) : -2*Math.ceil(shift)
                return yposition_addition(d, 1) - shift_scaled + padding_shift
            })
        if (shift_sign == -1) {
            d3.selectAll('.wx_bar.group2_bar').transition().delay(sub_step_time*3).duration(sub_step_time)
                .style('opacity', 0)
                .attr('y', function(d) {
                    padding_shift = (shift < 0) ? 2*Math.ceil(Math.abs(shift)) : -2*Math.ceil(shift)
                    return yposition_addition(d, 1) + shift_scaled - transfer_multiply_height - padding_shift
                })
        } else {
            d3.selectAll('.wx_bar.group2_bar').transition().delay(sub_step_time*4).duration(sub_step_time).style('opacity', 0.2)
        }
        d3.selectAll('.wx_bar.group1_bar').transition().delay(sub_step_time*4).duration(sub_step_time).style('opacity', 0.2)
    }


    var x = [-2.2, 2.2],
        x1 = x[0],
        x2 = x[1],
        w = [-1.8, -0.8],
        w1 = w[0],
        w2 = w[1],
        shift = w2*x2,
        shift_sign = Math.sign(shift*(w1*x1)),
        final_value = shift + w1*x1

    // create unit and modulo of data
    x1_data = create_interval_data(x1, 'x', w1)
    x2_data = create_interval_data(x2, 'x', w2)
    x1_start_data = create_interval_data(x1, 'x_start', w1)
    x2_start_data = create_interval_data(x2, 'x_start', w2)

    w1_data = create_interval_data(w1, 'w', w1)
    w2_data = create_interval_data(w2, 'w', w2)
    wx1_start_data = create_interval_data(x1*w1, 'wx_start', w1)
    wx2_start_data = create_interval_data(x2*w2, 'wx_start', w2)
    wx1_data = create_interval_data(x1*w1, 'wx', w1)
    wx2_data = create_interval_data(x2*w2, 'wx', w1)

    data1 = x1_data.concat(w1_data).concat(wx1_data).concat(x1_start_data).concat(wx1_start_data)
    data2 = x2_data.concat(w2_data).concat(wx2_data).concat(x2_start_data).concat(wx2_start_data)

    addwx_multiply(data1, transfer_multiply_group_1, 1)
    addwx_multiply(data2, transfer_multiply_group_2, 2)

    draw_multiply_links(x1_start_data, transfer_group_1)
    draw_multiply_links(x2_start_data, transfer_group_2)
    draw_multiply_links(x1_start_data, transfer_group_1, true)
    draw_multiply_links(x2_start_data, transfer_group_2, true)

    draw_addition_links(wx1_start_data, transfer_group_1, 1)
    draw_addition_links(wx2_start_data, transfer_group_2, 2)
    draw_addition_links(wx1_start_data, transfer_group_1, 1, 'first')
    draw_addition_links(wx2_start_data, transfer_group_2, 2, 'first')
    draw_addition_links(wx1_start_data, transfer_group_1, 1, 'second', w2*x2)

    multiply(1)
    multiply(2)
    move_to_addition(1)
    move_to_addition(2)
    add(shift, shift_sign)

    // draw a new bar
    //move bar to threshold
</script>

